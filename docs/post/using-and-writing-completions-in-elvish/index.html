<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
     
    <title>zzamboni.org  | Using and writing completions in Elvish</title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">

    <meta name="viewport" content="width=device-width,minimum-scale=1">
     <meta name="generator" content="Hugo 0.42.1" />
      
      
        <META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
      

     <link href='http://zzamboni.org/dist/main.css' rel='stylesheet' type="text/css" />
     <link href='http://zzamboni.org/css/site.css' rel='stylesheet' type="text/css" />
     <link href='http://zzamboni.org/css/syntax.css' rel='stylesheet' type="text/css" />

     

      <meta property="og:title" content="Using and writing completions in Elvish" />
<meta property="og:description" content="Like other Unix shells, Elvish has advanced command-argument completion capabilities. In this article I will explore the existing completions, and show you how you can create your own (and contribute them back to the community).
Using existing completions There is a growing body of shell completions that you can simply load and use.
Elvish has a still-small but growing collection of completions that have been created by its users. These are a few that I know of (let me know if you know others!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://zzamboni.org/post/using-and-writing-completions-in-elvish/" />



<meta property="article:published_time" content="2018-06-13T20:25:00&#43;02:00"/>

<meta property="article:modified_time" content="2018-06-13T20:25:00&#43;02:00"/>











<meta itemprop="name" content="Using and writing completions in Elvish">
<meta itemprop="description" content="Like other Unix shells, Elvish has advanced command-argument completion capabilities. In this article I will explore the existing completions, and show you how you can create your own (and contribute them back to the community).
Using existing completions There is a growing body of shell completions that you can simply load and use.
Elvish has a still-small but growing collection of completions that have been created by its users. These are a few that I know of (let me know if you know others!">


<meta itemprop="datePublished" content="2018-06-13T20:25:00&#43;02:00" />
<meta itemprop="dateModified" content="2018-06-13T20:25:00&#43;02:00" />
<meta itemprop="wordCount" content="3436">



<meta itemprop="keywords" content="elvish,shell,completions,unix,config," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Using and writing completions in Elvish"/>
<meta name="twitter:description" content="Like other Unix shells, Elvish has advanced command-argument completion capabilities. In this article I will explore the existing completions, and show you how you can create your own (and contribute them back to the community).
Using existing completions There is a growing body of shell completions that you can simply load and use.
Elvish has a still-small but growing collection of completions that have been created by its users. These are a few that I know of (let me know if you know others!"/>

        
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-109878074-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-2108021418174840",
    enable_page_level_ads: true
  });
</script>
      
      <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon.png">
      <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
      <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
      <link rel="manifest" href="/manifest.json">
      <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  </head>

  <body class="ma0 avenir bg-near-white production">

    
   
  

  
  
  <header class="cover bg-center" style="background-image: url('http://zzamboni.org/images/elvish-logo.svg');">
    <div class="pb5-l bg-black-60">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://zzamboni.org/" class="f3 fw2 hover-white no-underline white-90 dib">
      zzamboni.org
    </a>
    <div class="flex-l items-center">
      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/post/" title="Blog page">
              Blog
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/book/" title="Books page">
              Books
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/code/" title="Code page">
              Code
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/tags/" title="Tags page">
              Tags
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/contact/" title="Contact page">
              Contact
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="About page">
              About
            </a>
          </li>
          
        </ul>
      
      



  <a href="https://twitter.com/zzamboni" class="link-transition twitter link dib z-999 pt3 pt0-l mr2" title="Twitter link">
    <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

  </a>




    </div>
  </div>
</nav>

      <div class="tc-l pv4 ph3 ph4-ns">
        <h1 class="f2 f1-l fw2 white-90 mb0 mt0 lh-title">Using and writing completions in Elvish</h1>
        
      </div>
    </div>
  </header>



    <main class="pb7" role="main">
      
  <div class="flex-l mt2 mw8 center">
    <article class="center cf pv5 ph3 ph4-ns mw7">
      <p class="f6 b helvetica tracked">
        
        POST
      </p>
      <h1 class="f1 athelas">
        Using and writing completions in Elvish
      </h1>
        
        
      <time class="f6 mv4 dib tracked" datetime="2018-06-13T20:25:00&#43;02:00">
        June 13, 2018
      </time>
      <section class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray">
        

<p>Like other Unix shells, <a href="https://elvish.io/">Elvish</a> has advanced command-argument completion capabilities. In this article I will explore the existing completions, and show you how you can create your own (and contribute them back to the community).</p>

<h2 id="using-existing-completions">Using existing completions</h2>

<p>There is a growing body of shell completions that you can simply load and use.</p>

<p>Elvish has a still-small but growing collection of completions that have been created by its users. These are a few that I know of (let me know if you know others!):</p>

<ul>
<li><p>My own <a href="https://github.com/zzamboni/elvish-completions">zzamboni/elvish-completions</a> package, which contains completions for <a href="https://github.com/zzamboni/elvish-completions/blob/master/git.org">git</a> (providing automatically-generated completions for all commands and their options, plus hand-crafted argument completions for many of them), <a href="https://github.com/zzamboni/elvish-completions/blob/master/ssh.org">ssh</a>, <a href="https://github.com/zzamboni/elvish-completions/blob/master/vcsh.org">vcsh</a>, <a href="https://github.com/zzamboni/elvish-completions/blob/master/cd.org">cd</a>, and a few of Elvish&rsquo;s <a href="https://github.com/zzamboni/elvish-completions/blob/master/builtins.org">built-in functions and modules</a>. It also contains <a href="https://github.com/zzamboni/elvish-completions/blob/master/comp.org">comp</a>, a framework for building completers, which we will explore in more detail below. To use any of these modules, you just need to install the elvish-completions package, and then load the modules you want. For example:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">epm:install &amp;silent-if-installed github.com/zzamboni/elvish-completions
use github.com/zzamboni/elvish-completions/vcsh
use github.com/zzamboni/elvish-completions/cd
use github.com/zzamboni/elvish-completions/ssh
use github.com/zzamboni/elvish-completions/builtins
use github.com/zzamboni/elvish-completions/git</code></pre></div></li>

<li><p>xiaq&rsquo;s <a href="https://github.com/xiaq/edit.elv/blob/master/compl/go.elv">edit.elv/compl/go.elv</a>, which provides extensive hand-crafted completions for <code>go</code>. You can also install this one as an Elvish package:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">epm:install &amp;silent-if-installed github.com/xiaq/edit.elv
use github.com/xiaq/edit.elv/compl/go
go:apply</code></pre></div></li>

<li><p>occivink&rsquo;s <a href="https://github.com/occivink/config/blob/master/.elvish/lib/completers.elv">completers.elv</a> file, which contains completers for <code>kak</code>, <code>ssh</code>, <code>systemctl</code>, <code>ffmpeg</code> and a few other commands.</p></li>

<li><p>Tw&rsquo;s <a href="https://github.com/tw4452852/MyConfig/tree/master/config/.elvish/lib/completer">completer/</a> files, which contains completions for <code>adb</code>, <code>git</code> and <code>ssh</code>.</p></li>

<li><p>SolitudeSF&rsquo;s <a href="https://github.com/SolitudeSF/dot/blob/master/elvish/lib/completers.elv">completers.elv</a> file, which contains completers for <code>cd</code>, <code>kak</code>, <code>kitty</code>, <code>git</code>, <code>man</code>, <code>pkill</code> and quite a few other commands.</p></li>
</ul>

<p>As of this writing, there is no &ldquo;official&rdquo; collection of Elvish completions, so feel free to look at the existing ones and choose/use the ones that work best for you.</p>

<p>Since the collection is not yet very big, it&rsquo;s likely you will want to build your own completions. This is what the next section is about.</p>

<h2 id="creating-your-own-completions">Creating your own completions</h2>

<p>Elvish has a simple but powerful argument-completion mechanism. You can find the full documentation <a href="https://elvish.io/ref/edit.html#completion-api">in the Elvish reference</a>, but let&rsquo;s take a quick look here.</p>

<h3 id="basic--built-in--argument-completion-mechanisms">Basic (built-in) argument completion mechanisms</h3>

<p>Command argument completion in Elvish is implemented by functions stored inside <code>$edit:completion:arg-completer</code>. This variable is a map in which the indices are command names, and the values are functions which must receive a variable number of arguments. When the user types <code>cat</code> <kbd>Space</kbd> <kbd>Tab</kbd>, the function stored in <code>$edit:completion:arg-completer[cat]</code> (if any) is called, as follows:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">$edit:completion:arg-completer[cat] cat &#39;&#39;</code></pre></div>
<p>The function receives the full current command line as arguments, including the current argument, which might be empty as in the example above, or be a partially typed string. For example, if the user types <code>cat f</code> <kbd>Tab</kbd>, the completer function will be called like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">$edit:completion:arg-completer[cat] cat &#39;f&#39;</code></pre></div>
<p>The completion function must use its arguments to determine the appropriate completions at that point, and return them by one of the following methods (which can be combined):</p>

<ul>
<li>Output the completions to stdout, one per line;</li>
<li>Output the completions to the data stream (using <code>put</code>);</li>

<li><p>Output the completions using the <code>edit:complex-candidate</code> command, which can additionally specify a suffix to append to the completion in the completion menu or in the returned value, and a style to use (as accepted by <code>edit:styled</code>). The full syntax of <code>edit:complex-candidate</code> is as follows:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">edit:complex-candidate &amp;code-suffix=&#39;&#39; &amp;display-suffix=&#39;&#39; &amp;style=&#39;&#39; $string</code></pre></div>
<p><code>$string</code> is the option to display; <code>&amp;code-suffix</code> indicates a suffix to be appended to the completion string when the user selects it; <code>&amp;display-suffix</code> indicates a suffix to be shown in the completion menu (but which is not returned as part of the completion); and <code>&amp;style</code> indicates a text style to use in the completion menu.</p></li>
</ul>

<p>Keep in mind that the options returned by the completion function are additionally filtered by what the user has typed so far. This means that the last argument can usually be ignored, since Elvish will automatically do the filtering. An exception to this is if you want to return different <em>types of things</em> depending on what the user has typed already. For example, if the last argument start with <code>-</code>, you may want to return the possible command-line options, and return regular argument completions otherwise.</p>

<p><strong>Example #1:</strong> A very simple completer for the <code>brew</code> command:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">edit:completion:arg-completer[brew] = [@cmd]{
  len = (count $cmd)
  if (eq $len 2) {
    if (has-prefix $cmd[-1] -) {
      put &#39;--version&#39; &#39;--verbose&#39;
    } else {
      put install uninstall
    }
  } elif (eq $len 3) {
    brew search | eawk [l @f]{ put $@f }
  }
}</code></pre></div>
<p>If the function receives two arguments, we check to see if the last argument begins with a dash. If so, we return the possible command-line options, otherwise we return the two commands <code>install</code> and <code>uninstall</code>. If we receive three arguments (i.e. we are past the initial command), we return the list of possible packages to install or uninstall.</p>

<p>You may noticed that there are many cases that this simple function does not handle correctly. For example, if you type <code>brew --verbose</code> <kbd>Space</kbd> <kbd>Tab</kbd>, you get the list of packages as completion, which does not make sense at that point. We will look at more complex and complete completion functions next.</p>

<p>The first step to more complex completions is the <code>edit:complete-getopt</code> command, which allows us to specify a sequence of positional completion functions. The general syntax of the command is:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">edit:complete-getopt $args $opts $handlers</code></pre></div>
<p>Please see <a href="https://elvish.io/ref/edit.html#editcomplete-getopt">its documentation</a> for a full description of the arguments.</p>

<p><strong>Example #2:</strong> The completer for <code>brew</code> shown before can be specified like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">edit:completion:arg-completer[brew] = [@cmd]{
  edit:complete-getopt $cmd[1:] \
  [[&amp;long=version] [&amp;long=verbose]] \
  [
    [_]{ put install uninstall }
    [_]{ brew search | eawk [_ @f]{ put $@f } }
    ...
  ]
}</code></pre></div>
<p>This new completer overcomes a few of the limitations in our previous attempt. For one, the <code>install</code> and <code>uninstall</code> commands are now properly completed even if you specify options before. Furthermore, the <code>...</code> at the end of the handler list indicates that the previous one (the package names) will be repeated for all further arguments - this makes it possible to complete multiple package names to install or uninstall. However, it still has some limitations! For example, it will give you all existing packages as possible arguments to <code>uninstall</code>, which only accepts already installed packages.</p>

<p>In addition to <code>complete-getopt</code>, Elvish includes a few other functions to help build completers:</p>

<ul>
<li><code>edit:complete-filename</code> produces a listing of all the files and directories in the directory of its argument, and is the default completion function when no other completer is specified. See its <a href="https://elvish.io/ref/edit.html#editcomplete-filename">documentation</a> for full details.</li>

<li><p><code>edit:complete-sudo</code> provides completions for commands like <code>sudo</code> which take a command as their first argument. It is the default completer for the <code>sudo</code> command, so that if you type <code>sudo</code> <kbd>Space</kbd> <kbd>Tab</kbd>, you get a list of all the commands on your execution path. It can be reused for other commands, for example <code>time</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">edit:completion:arg-completer[time] = $edit:complete-sudo~</code></pre></div></li>
</ul>

<p>Finally, note that if <code>$edit:completion:arg-completer['']</code> exists, it will be called as a fall-back completer if no command-specific argument completer exists. You can see that the default completer is <code>edit:complete-filename</code>, as mentioned before:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">~&gt; put $edit:completion:arg-completer[&#39;&#39;]
▶ $edit:complete-filename~</code></pre></div>
<p>With the tools you know so far, you can already create fairly complex completers. In the next section, we will explore <code>comp</code>, an external library I wrote to make it easier to specify complex completion trees.</p>

<h3 id="complex-completions-using-the-comp-framework">Complex completions using the <code>comp</code> framework</h3>

<p>The built-in completion functions make it possible to build any completer you want. However, you might realize that for more complex cases, the specifications can be quite complex. For this reason, I wrote <a href="https://github.com/zzamboni/elvish-completions/blob/master/comp.org">the <code>comp</code> library</a> as a framework to more easily specify completion functions. The basic Elvish mechanisms and functions are still used in the backend, so you can rest assured about their compatibility with the basic mechanisms.</p>

<p>As a first step, if you haven&rsquo;t done so already, you should install the <code>elvish-completions</code> package using <a href="https://elvish.io/ref/epm.html">epm</a>:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">use epm
epm:install github.com/zzamboni/elvish-completions</code></pre></div>
<p>From the file where you will define your completions (or from your interactive session if you just want to play with it), load the <code>comp</code> module:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">use github.com/zzamboni/elvish-completions/comp</code></pre></div>
<p>The main entry points for this module are <code>comp:item</code>, <code>comp:sequence</code> and <code>comp:subcommands</code>. Each one receives a single argument containing a  &ldquo;completion definition&rdquo;, which indicates how the completions will be produced. Each one receives a different kind of completion structure, and returns a ready-to-use completion function, which can be assigned directly to an element of <code>$edit:completion:arg-completer</code>. A simple example:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">edit:completion:arg-completer[foo] = (comp:item [ bar baz ])</code></pre></div>
<p>If you type this in your terminal, and then type <code>foo&lt;space&gt;</code> and press <kbd>Tab</kbd>, you will see the appropriate completions:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">&gt; foo &lt;Tab&gt;
 COMPLETING argument _
 bar  baz</code></pre></div>
<p>To create completions for new commands, your main task is to define the corresponding completion definition. The different types of definitions and functions are explained below, with examples of the different available structures and features.</p>

<p><strong>Note:</strong> the main entry points return a ready-to-use argument handler function. If you ever need to expand a completion definition directly (maybe for some advanced usage), you can call <code>comp:-expand-item</code>, <code>comp:-expand-sequence</code> and <code>comp:-expand-subcommands</code>, respectively. These functions all take the definition structure and the current command line, and return the appropriate completions at that point.</p>

<p>We now look at the different types of completion definitions understood by <code>comp</code>.</p>

<h4 id="items">Items</h4>

<p>The base building block is the &ldquo;item&rdquo;, can be one of the following:</p>

<ul>
<li>An array containing all the potential completions (it can be empty, in which case no completions are provided). This is useful for providing a static list of completions.</li>
<li>A function which returns the potential completions (it can return nothing, in which case no completions are provided). The function should have one of the following arities, which affect which arguments will be passed to it (other arities are not valid, and in that case the item will not be executed):

<ul>
<li>If it takes no arguments, no arguments are passed to it.</li>
<li>If it takes a single argument, it gets the current (last) component of the command line <code>@cmd</code>; this is just like the handler functions understood by the <code>edit:complete-getopt</code> command.</li>
<li>If it takes a rest argument, it gets the full current command line (the contents of <code>@cmd</code>); this is just like the functions assigned to <code>$edit:completion:arg-completer</code>.</li>
</ul></li>
</ul>

<p><strong>Example #3:</strong> a simple completer for <code>cd</code></p>

<p>In this case, we define a function which receives the current &ldquo;stem&rdquo; (the part of the filename the user has typed so far) and offers all the relevant files, then filters those which are directories, and returns them as completion possibilities. We pass the function directly as a completion item to <code>comp:-expand</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">fn complete-dirs [arg]{ put {$arg}* | each [x]{ if (-is-dir $x) { put $x } } }
edit:completion:arg-completer[cd] = (comp:item $complete-dirs~)</code></pre></div>
<p>For file and directory completion, you can use the utility function <code>comp:files</code> instead of defining your own function (see <a href="#utility-functions">Utility functions</a>). <code>comp:files</code> uses <code>edit:complete-filename</code> in the backend but offers a few additional filtering options:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">edit:completion:arg-completer[cd] = (comp:item [arg]{ comp:files $arg &amp;dirs-only })</code></pre></div>
<h4 id="sequences-and-command-line-options">Sequences and command-line options</h4>

<p>Completion items can be aggregated in a <em>sequence of items</em> and used with the <code>comp:sequence</code> function when you need to provide different completions for different positional arguments of a command, including support for command-line options at the beginning of the command (<code>comp:sequence</code> uses <code>edit:complete-getopt</code> in the backend, but provides a few additional convenient features). The definition structure in this case has to be an array of items, which will be applied depending on their position within the command parameter sequence. If the the last element of the list is the string <code>...</code> (three periods), the next-to-last element of the list is repeated for all later arguments. If no completions should be provided past the last argument, simply omit the periods. If a sequence should produce no completions at all, you can use an empty list <code>[]</code>. If any specific elements of the sequence should have no completions, you can specify <code>{ comp:empty }</code> or <code>[]</code> as its value.</p>

<p>If the <code>&amp;opts</code> option is passed to the <code>comp:sequence</code> function, it must contain a single definition item which produces a list of command-line options that are allowed at the beginning of the command, when no other arguments have been provided. Options can be specified in either of the following formats:</p>

<ul>
<li>As a string which gets converted to a long-style option; e.g. <code>all</code> to specify the <code>--all</code> option. The string must not contain the dashes at the beginning.</li>
<li>As a map in the style of <code>complete-getopt</code>, which may contain the following keys:

<ul>
<li><code>short</code> for the short one-letter option;</li>
<li><code>long</code> for the long-option string;</li>
<li><code>desc</code> for a descriptive string which gets shown in the completion menu;</li>
<li><code>arg-mandatory</code> or <code>arg-optional</code>: either one but not both can be set to <code>$true</code> to indicate whether the option takes a mandatory or optional argument;</li>
<li><code>arg-completer</code> can be specified to produce completions for the option argument. If specified, it must contain completion item as described in <a href="#items">Items</a>, and which will be expanded to provide completions for that argument&rsquo;s values.</li>
</ul></li>
</ul>

<p>Simple example of a completion data structure for option <code>-t</code> (long form <code>--type</code>), which has a mandatory argument which can be <code>elv</code>, <code>org</code> or <code>txt</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">[ &amp;short=t
  &amp;long=type
  &amp;desc=&#34;Type of file to show&#34;
  &amp;arg-mandatory=$true
  &amp;arg-completer= [ elv org txt ]
]</code></pre></div>
<p><strong>Note:</strong> options are only offered as completions when the use has typed a dash as the first character. Otherwise the argument completers are used.</p>

<p><strong>Example #4:</strong> we can improve on the previous completer for <code>cd</code> by preventing more than one argument from being completed (only the first argument will be completed using <code>complete-dirs</code>, since the list does not end with <code>...</code>):</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">edit:completion:arg-completer[cd] = (comp:sequence [ [arg]{ comp:files $arg &amp;dirs-only }])</code></pre></div>
<p><strong>Example #5:</strong> a simple completer for <code>ls</code> with a subset of its options. Note that <code>-l</code> and <code>-R</code> are only provided as completions when you have not typed any filenames yet. Also note that we are using <a href="#utility-functions">comp:files</a> to provide the file completions, and the <code>...</code> at the end of the sequence to use the same completer for all further elements.</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">ls-opts = [
  [ &amp;short=l                 &amp;desc=&#39;use a long listing format&#39; ]
  [ &amp;short=R &amp;long=recursive &amp;desc=&#39;list subdirectories recursively&#39; ]
]
edit:completion:arg-completer[ls] = (comp:sequence &amp;opts=$ls-opts [ $comp:files~ ... ])</code></pre></div>
<p><strong>Example #6:</strong> See the <a href="https://github.com/zzamboni/elvish-completions/blob/master/ssh.org">ssh completer</a> for a real-world example of using sequences.</p>

<h4 id="subcommands">Subcommands</h4>

<p>Finally, completion sequences can be aggregated into <em>subcommand structures</em> using the <code>comp:subcommands</code> function, to provide completion for commands such as <code>git</code>, which accept multiple subcommands, each with their own options and completions. In this case, the definition is a map indexed by subcommand names. The value of each element can be a <code>comp:item</code>,  a <code>comp:sequence</code> or another <code>comp:subcommands</code> (to provide completion for sub-sub-commands, see the example below for <code>vagrant</code>). The <code>comp:subcommands</code> function can also receive the <code>&amp;opts</code> option to generate any available top-level options.</p>

<p><strong>Example #7:</strong> let us reimplement our completer for the <code>brew</code> package manager, but now with support for the <code>install</code>, <code>uninstall</code> and <code>cat</code> commands. <code>install</code> and <code>cat</code> gets as completions all available packages (the output of the <code>brew search</code> command), while <code>uninstall</code> only completes installed packages (the output of <code>brew list</code>). Note that for <code>install</code> and <code>uninstall</code> we automatically extract command-line options from their help messages using the <code>comp:extract-opts</code> function (wrapped into the <code>-brew-opts</code> function), and pass them as the <code>&amp;opts</code> option in the corresponding sequence functions. Also note that all <code>&amp;opts</code> elements get initialized at definition time (they are arrays), whereas the sequence completions get evaluated at runtime (they are lambdas), to automatically update according to the current packages. The <code>cat</code> command sequence allows only one option. The load-time initialization of the options incurs a small delay, and you could replace these with lambdas as well so that the options are computed at runtime. Note also the usage of the <code>comp:decorate</code> function to colorize the package names in different colors for each command.</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">fn -brew-opts [cmd]{
  brew $cmd -h | take 1 | \
  comp:extract-opts &amp;regex=&#39;--(\w[\w-]*)&#39; &amp;regex-map=[&amp;long= 1]
}
brew-completions = [
  &amp;install= (comp:sequence &amp;opts= [ (-brew-opts install) ] \
    [ { brew search | comp:decorate &amp;style=green } ... ]
  )
  &amp;uninstall= (comp:sequence &amp;opts= [ (-brew-opts uninstall) ] \
    [ { brew list | comp:decorate &amp;style=red }   ... ]
  )
  &amp;cat= (comp:sequence [{ brew search | comp:decorate &amp;style=blue }])
]
edit:completion:arg-completer[brew] = (comp:subcommands \
  &amp;opts= [ version verbose ] $brew-completions
)</code></pre></div>
<p>Note that in contrast to our previous <code>brew</code> completer, this definition is much more expressive, accurate, and much easier to extend.</p>

<p><strong>Example #8:</strong> a simple completer for a subset of <code>vagrant</code>, which receives commands which may have subcommands and options of their own. Note that the value of <code>&amp;up</code> is a <code>comp:sequence</code>, but the value of <code>&amp;box</code> is another <code>comp:subcommands</code> which includes the completions for <code>box add</code> and <code>box remove</code>. Also note the use of the <code>comp:extract-opts</code> function to extract the command-line arguments automatically from the help messages. The output of the <code>vagrant</code> help messages matches the default format expected by <code>comp:extract-opts</code>, so we don&rsquo;t even have to specify a regular expression like for <code>brew</code>.</p>

<p><strong>Tip:</strong> note that the values of <code>&amp;opts</code> are functions (e.g. <code>{ vagrant-up -h | comp:extract-opts }</code>) instead of arrays (e.g. <code>( vagrant up -h | comp:extract-opts )</code>). As mentioned in the previous example, both are valid, but in the latter case they are all initialized at load time (when the data structure is defined), which might introduce a delay, particularly with more command definitions. By using functions the options are only extracted at runtime when the completion is requested. For further optimization, <code>vagrant-opts</code> could be made to memoize the values so that the delay only occurs the first time.</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">vagrant-completions = [
  &amp;up= (comp:sequence [] \
    &amp;opts= { vagrant up -h | comp:extract-opts }
  )
  &amp;box= (comp:subcommands [
      &amp;add= (comp:sequence [] \
        &amp;opts= { vagrant box add -h | comp:extract-opts }
      )
      &amp;remove= (comp:sequence [ { \
            vagrant box list | eawk [_ @f]{ put $f[0] } \
        } ... ] \
        &amp;opts= { vagrant box remove -h | comp:extract-opts }
      )
])]

edit:completion:arg-completer[vagrant] = (comp:subcommands \
  &amp;opts= [ version help ] $vagrant-completions
)</code></pre></div>
<p><strong>Example #9:</strong> See the <a href="https://github.com/zzamboni/elvish-completions/blob/master/git.org">git completer</a> for a real-world subcommand completion example, which also shows how extensively auto-population of subcommands and options can be done by extracting information from help messages.</p>

<h4 id="utility-functions">Utility functions</h4>

<p>The <code>comp</code> module includes a few utility functions, some of which you have seen already in the examples.</p>

<p><code>comp:decorate</code> maps its input through <code>edit:complex-candidate</code> with the given options. Can be passed the same options as <a href="https://elvish.io/ref/edit.html#argument-completer">edit:complex-candidate</a>. In addition, if <code>&amp;suffix</code> is specified, it is used to set both <code>&amp;display-suffix</code> and <code>&amp;code-suffix</code>. Input can be given either as arguments or through the pipeline:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">&gt; comp:decorate &amp;suffix=&#34;:&#34; foo bar
▶ (edit:complex-candidate foo &amp;code-suffix=: &amp;display-suffix=: &amp;style=&#39;&#39;)
▶ (edit:complex-candidate bar &amp;code-suffix=: &amp;display-suffix=: &amp;style=&#39;&#39;)
&gt; put foo bar | comp:decorate &amp;style=&#34;red&#34;
▶ (edit:complex-candidate foo &amp;code-suffix=&#39;&#39; &amp;display-suffix=&#39;&#39; &amp;style=31)
▶ (edit:complex-candidate bar &amp;code-suffix=&#39;&#39; &amp;display-suffix=&#39;&#39; &amp;style=31)</code></pre></div>
<p><code>comp:extract-opts</code> takes input from the pipeline and extracts command-line option data structures from its output. By default it understand the following common formats:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">-o, --option                Option description
-p, --print[=&lt;what&gt;]        Option with an optional argument
    --select &lt;type&gt;         Option with a mandatory argument</code></pre></div>
<p>Typical use would be to populate an <code>&amp;opts</code> element with something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">comp:sequence &amp;opts= { vagrant -h | comp:extract-opts } [ ... ]</code></pre></div>
<p>The regular expression used to extract the options can be specified with the <code>&amp;regex</code> option. Its default value (which parses the common formats shown above) is:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">&amp;regex=&#39;^\s*(?:-(\w),?\s*)?(?:--?([\w-]+))?(?:\[=(\S+)\]|[ =](\S+))?\s*?\s\s(\w.*)$&#39;</code></pre></div>
<p>The mapping of capture groups from the regex to option components is defined by the <code>&amp;regex-map</code> option. Its default value (which also shows the available fields) is:</p>
<div class="highlight"><pre class="chroma"><code class="language-elvish" data-lang="elvish">&amp;regex-map=[&amp;short=1 &amp;long=2 &amp;arg-optional=3 &amp;arg-mandatory=4 &amp;desc=5]</code></pre></div>
<p>At least one of <code>short</code> or <code>long</code> must be present in <code>regex-map</code>. The <code>arg-optional</code> and <code>arg-mandatory</code> groups, if present, are handled specially: if any of them is not empty, then its contents is stored as <code>arg-desc</code> in the output, and the corresponding <code>arg-mandatory</code> / <code>arg-optional</code> is set to <code>$true</code>.</p>

<p>If <code>&amp;fold</code> is <code>$true</code>, then the input is preprocessed to join option descriptions which span more than one line (the heuristic is not perfect and may not work in all cases, also for now it only joins one line after the option).</p>

<h2 id="contributing-your-completions">Contributing your completions</h2>

<p>So you have created a brand-new completion function and would like to share it with the Elvish community. Nothing could be easier! You have two main options:</p>

<ul>
<li>Publish them on your own. For example, if you put your <code>.elv</code> files into their own repository in GitHub or Gitlab, they are ready to be installed and used using <a href="https://elvish.io/ref/epm.html">epm</a>.</li>
<li>Contribute it to an existing repository (for example <a href="https://github.com/zzamboni/elvish-completions">elvish-completions</a>). Just add your files, submit a pull request, and you are done.</li>
</ul>

<p>I hope you have found this tutorial useful. Please let me know in the comments if you have any questions, feedback or if you find something that is incorrect.</p>

<p>Now, go have fun with Elvish!</p>

      </section>
      

  <ul class="list dib ml0 pl0" id="tags">
    <li class="b black dib mb2 mr3">Tags: </li>
    
      <li class="black dib mb2 mr2"><a href="/tags/elvish" class="link mid-gray dim">elvish</a> </li>
    
      <li class="black dib mb2 mr2"><a href="/tags/shell" class="link mid-gray dim">shell</a> </li>
    
      <li class="black dib mb2 mr2"><a href="/tags/completions" class="link mid-gray dim">completions</a> </li>
    
      <li class="black dib mb2 mr2"><a href="/tags/unix" class="link mid-gray dim">unix</a> </li>
    
      <li class="black dib mb2 mr2"><a href="/tags/config" class="link mid-gray dim">config</a> </li>
    
  </ul>
  
  
  
  
  
    <div class="mt5 f6 gray nested-lh-copy bg-light-gray ph3 pv2 measure-wide-l">
      <ul class="list dib ml0 pl0">
        <li class="black dib mb2 mr2">
          Related:
        </li>
        
          
        
          
            <li class="mb2 mr3">
              <a href="/post/bang-bang---shell-shortcuts-in-elvish/" class="link mid-gray dim">
                 Bang-Bang (!!, !$) Shell Shortcuts in Elvish
              </a>
            </li>
          
        
          
            <li class="mb2 mr3">
              <a href="/post/my-elvish-configuration-with-commentary/" class="link mid-gray dim">
                 My Elvish Configuration With Commentary
              </a>
            </li>
          
        
          
            <li class="mb2 mr3">
              <a href="/post/elvish-an-awesome-unix-shell/" class="link mid-gray dim">
                 Elvish, an awesome Unix shell
              </a>
            </li>
          
        
      </ul>
    </div>
  


      <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zzamboni-org" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </article>
    <div class="ph3 mt2 mt6-ns">
      <div class="bg-light-gray pa3">
      <p class="list b mb3">What's in this Post</p>
      <nav id="TableOfContents">
<ul>
<li class="list f5 w-100 hover-bg-white nl1">
<ul>
<li class="list f5 w-100 hover-bg-white nl1"><a class="link ph2 pv2 db black"href="#using-existing-completions">Using existing completions</a></li>
<li class="list f5 w-100 hover-bg-white nl1"><a class="link ph2 pv2 db black"href="#creating-your-own-completions">Creating your own completions</a>
<ul>
<li class="list f5 w-100 hover-bg-white nl1"><a class="link ph2 pv2 db black"href="#basic--built-in--argument-completion-mechanisms">Basic (built-in) argument completion mechanisms</a></li>
<li class="list f5 w-100 hover-bg-white nl1"><a class="link ph2 pv2 db black"href="#complex-completions-using-the-comp-framework">Complex completions using the <code>comp</code> framework</a>
<ul>
<li class="list f5 w-100 hover-bg-white nl1"><a class="link ph2 pv2 db black"href="#items">Items</a></li>
<li class="list f5 w-100 hover-bg-white nl1"><a class="link ph2 pv2 db black"href="#sequences-and-command-line-options">Sequences and command-line options</a></li>
<li class="list f5 w-100 hover-bg-white nl1"><a class="link ph2 pv2 db black"href="#subcommands">Subcommands</a></li>
<li class="list f5 w-100 hover-bg-white nl1"><a class="link ph2 pv2 db black"href="#utility-functions">Utility functions</a></li>
</ul></li>
</ul></li>
<li class="list f5 w-100 hover-bg-white nl1"><a class="link ph2 pv2 db black"href="#contributing-your-completions">Contributing your completions</a></li>
</ul></li>
</ul>
</nav>
</div>
<br/></div>
  </div>

    </main>
    <footer class="bg-near-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
    <a class="f5 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://zzamboni.org/" >
      &copy; 2018 Diego Zamboni
    </a>
    <div class="f5 fw1 no-underline white-70 dn dib-ns tl pv2 ph3" >Made with love, coffee,&nbsp;<a class="no-underline hover-white white-70" href="https://www.gnu.org/software/emacs/">Emacs 26.1 </a> &plus;
                <a class="no-underline hover-white white-70" href="https://orgmode.org/">Org mode 9.1.13 </a> &plus;
                <a class="no-underline hover-white white-70" href="https://ox-hugo.scripter.co/">ox-hugo</a>&nbsp;and published using <a class="no-underline hover-white white-70" href="http://gohugo.io/">Hugo 0.42.1</a>
            &plus; <a class="no-underline hover-white white-70" href="https://github.com/budparr/gohugo-theme-ananke">Ananke</a></div>
    



  <a href="https://twitter.com/zzamboni" class="link-transition twitter link dib z-999 pt3 pt0-l mr2" title="Twitter link">
    <svg height="32px"  style="enable-background:new 0 0 67 67;" version="1.1" viewBox="0 0 67 67" width="32px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167,22.283c-2.619,0.953-4.274,3.411-4.086,6.101  l0.063,1.038l-1.048-0.127c-3.813-0.487-7.145-2.139-9.974-4.915l-1.383-1.377l-0.356,1.017c-0.754,2.267-0.272,4.661,1.299,6.271  c0.838,0.89,0.649,1.017-0.796,0.487c-0.503-0.169-0.943-0.296-0.985-0.233c-0.146,0.149,0.356,2.076,0.754,2.839  c0.545,1.06,1.655,2.097,2.871,2.712l1.027,0.487l-1.215,0.021c-1.173,0-1.215,0.021-1.089,0.467  c0.419,1.377,2.074,2.839,3.918,3.475l1.299,0.444l-1.131,0.678c-1.676,0.976-3.646,1.526-5.616,1.568  C19.775,43.256,19,43.341,19,43.405c0,0.211,2.557,1.397,4.044,1.864c4.463,1.377,9.765,0.783,13.746-1.568  c2.829-1.673,5.657-5,6.978-8.221c0.713-1.716,1.425-4.851,1.425-6.354c0-0.975,0.063-1.102,1.236-2.267  c0.692-0.678,1.341-1.419,1.467-1.631c0.21-0.403,0.188-0.403-0.88-0.043c-1.781,0.636-2.033,0.551-1.152-0.402  c0.649-0.678,1.425-1.907,1.425-2.267c0-0.063-0.314,0.042-0.671,0.233c-0.377,0.212-1.215,0.53-1.844,0.72l-1.131,0.361l-1.027-0.7  c-0.566-0.381-1.361-0.805-1.781-0.932C39.766,21.902,38.131,21.944,37.167,22.283z M33,64C16.432,64,3,50.569,3,34S16.432,4,33,4  s30,13.431,30,30S49.568,64,33,64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:;"/></svg>

  </a>




  </div>
</footer>

    <script src="http://zzamboni.org/dist/app.bundle.js" async></script>

  </body>
</html>
