#+hugo_base_dir: ../
#+seq_todo: TODO DRAFT DONE
#+options: creator:t
#+property: header-args :eval never-export
#+hugo_front_matter_key_replace: description>summary

#+macro: updatetime {{{time(%B %e\, %Y)}}}

#+title: zzamboni.org source file
#+author: Diego Zamboni
#+email: diego@zzamboni.org

This file is the source for all new and updated content on [[http://zzamboni.org/][my website]] since March 2018. Content here may be in progress or incomplete. This file gets converted to [[http://gohugo.io/][Hugo]] files by the excellent [[https://ox-hugo.scripter.co/][ox-hugo]].

*You really should not read it here but at [[http://zzamboni.org/][zzamboni.org]]*.

* Table of Contents                                          :TOC_3:noexport:
- [[#pages][Pages]]
  - [[#about][About]]
    - [[#my-online-past][My online past]]
    - [[#about-this-site][About this site]]
    - [[#image-attributions][Image attributions:]]
  - [[#contact][Contact]]
  - [[#books][Books]]
- [[#book-pages][Book pages]]
  - [[#learning-cfengine-3][Learning CFEngine 3]]
- [[#ideas][Ideas]]
  - [[#using-and-extending-seal][Using and extending Seal]]
  - [[#sending-things-to-omnifocus][Sending things to OmniFocus]]
  - [[#ox-hugo][ox-hugo]]
  - [[#cryfs][CryFS]]
  - [[#hosting-a-hugo-blog-in-github][Hosting a Hugo blog in GitHub]]
- [[#posts][Posts]]
  - [[#literate-config-files][Literate config files]]
    - [[#my-emacs-configuration-with-commentary][My Emacs Configuration, With Commentary]]
    - [[#my-hammerspoon-configuration-with-commentary][My Hammerspoon Configuration, With Commentary]]
    - [[#my-elvish-configuration-with-commentary][My Elvish Configuration With Commentary]]
  - [[#emacs][Emacs]]
    - [[#beautifying-org-mode-in-emacs][Beautifying Org Mode in Emacs]]
  - [[#hammerspoon][Hammerspoon]]
  - [[#elvish][Elvish]]
    - [[#bang-bang---shell-shortcuts-in-elvish][Bang-Bang (!!, !$) Shell Shortcuts in Elvish]]
    - [[#using-and-writing-completions-in-elvish][Using and writing completions in Elvish]]
  - [[#other][Other]]
    - [[#my-blogging-workflow-with-emacs-org-modeox-hugo-hugo-and-github][My blogging workflow with Emacs, org-mode+ox-hugo, Hugo and GitHub]]
- [[#footnotes][Footnotes]]

* Pages

This section contains all the static pages.

** DONE About
CLOSED: [2018-03-22 Thu 19:40]
:PROPERTIES:
:export_hugo_section: about
:export_hugo_custom_front_matter: :featured_image /images/legoland.jpg
:export_hugo_weight: 06
:export_file_name: _index
:export_hugo_aliases: /about.html
:END:

*Who:* I am a computer scientist, consultant, programmer, sysadmin, author and overall geek, now turned project leader and engineering team manager. I am from Mexico but live in Switzerland with my awesome wife and our two beautiful daughters.

*What:* I work as the lead of a development team in the Cloud Platform Division of [[http://swisscom.com/][Swisscom]], where I am applying my experience and background in security, configuration management, cloud computing and automation to build the next-generation cloud infrastructure for Swisscom and its customers. I am also the author of [[http://cf-learn.info]["Learning CFEngine 3"]].

*Where:* I was born in Argentina, but have moved around all my life.  When I was very young I moved to Mexico, where I lived in four different cities before moving to the U.S. to pursue my Ph.D. at [[http://www.cerias.purdue.edu/][Purdue University]] under the direction of [[http://spaf.cerias.purdue.edu/][Gene Spafford]]. Upon finishing my studies, my wife and I decided to go to Switzerland, where I worked at the [[http://www.zurich.ibm.com/][IBM Zurich Research Lab]]. Eight years and two kids later, we [[file:/brt/2009/09/08/going-home/index.html][moved to Mexico]] in late 2009. In 2015, we moved back to Switzerland.

*Long version:* If you are interested, here's my [[file:/vita.html][curriculum vitae]]. For other useless trivia about me, see [[http://www.zzamboni.org/brt/2007/03/07/blog-tagged/index.html][here]].

*** My online past

- 2009-2016: During this time my blog went through several iterations, hosted/powered by [[http://www.posterous.com/][Posterous]], [[https://jekyllrb.com/][Jekyll]], [[http://octopress.org/][Octopress]], [[https://postach.io/site][Postach.io]] and [[https://github.com/zzamboni/enwrite][Enwrite]]. All blog entries from this period have been merged into [[file:/post][my current blog]];
- 2005-2009: My blog titled [[file:/brt][BrT]], powered mainly by a self-hosted [[https://wordpress.org/][Wordpress]], with some intermixed use of Posterous. What you find at the link is a static archive copy;
- 1997-2001: My hand-maintained [[http://homes.cerias.purdue.edu/~zamboni/][web page at Purdue University]].

*** About this site

This entire site is generated by [[http://gohugo.io][Hugo]] and served by [[http://github.com/][GitHub]] through the incredibly useful [[http://pages.github.com/][GitHub Pages]] feature.

Both the source and the generated website are stored in the [[https://github.com/zzamboni/zzamboni.org][zzamboni/zzamboni.org]] GitHub repository, which is devoted to this content.  Recently I started using [[https://ox-hugo.scripter.co/][ox-hugo]] to generate the content from [[https://github.com/zzamboni/zzamboni.org/blob/master/content-org/zzamboni.org][a single source file]] in [[https://orgmode.org/][org-mode]] format, although all the older articles and pages are still stored in their original source Markdown files (I gradually convert them whenever I update them). Some of my [[file:/code][project]] pages are stored in the =gh-pages= branch of their own github repositories. Since GitHub Pages supports custom domains, all of them can be transparently hosted under the zzamboni.org domain.

I think it's incredible that all of this infrastructure is so easy to use and available for free.

*** Image attributions:

- C128 Code (code header background) is from the source code listing from my Commodore 128 program [[http://zzamboni.org/brt/2008/01/24/supercataloger-128][Supercataloguer 128]].
- [[https://www.pexels.com/photo/alphabet-board-game-bundle-close-up-278888/][Scrabble letters]] ([[file:../post][blog]] header background) from [[https://www.pexels.com/][Pexels]], licensed under [[https://www.pexels.com/photo-license/][CC0]].
- All other header background photos were taken either by my wife or me.

If you have any concerns or questions about the images used in this site, please [[file:../contact][let me know]].

** DONE Contact
CLOSED: [2018-03-25 Sun 18:34]
:PROPERTIES:
:export_hugo_section: contact
:export_hugo_custom_front_matter: :featured_image /images/phone-booth-red-trimmed.jpg
:export_hugo_weight: 05
:export_file_name: _index
:export_hugo_aliases: /contact.html
:END:

If you have any questions, comments or feedback about this site, please use the form below to send me a message.

----

@@html:{{< form-contact action="http://formspree.io/diego@zzamboni.org" >}}@@

** DONE Books
CLOSED: [2018-03-25 Sun 20:11]
:PROPERTIES:
:export_hugo_section: book
:export_hugo_custom_front_matter: :featured_image /images/book-box-thin.jpg
:export_hugo_weight: 02
:export_file_name: _index
:END:

* Book pages

The individual pages for each book.

** DONE Learning CFEngine 3
CLOSED: [2018-03-25 Sun 21:05]
:PROPERTIES:
:export_hugo_section: book
:export_file_name: cfengine
:export_hugo_custom_front_matter: :finalURL http://cf-learn.info/
:END:

{{< bookimglink style="float:right" >}}

I am the author of "Learning CFEngine 3", the best book for learning [[http://cfengine.com/][CFEngine]].

The book has its own webpage at http://cf-learn.info, please visit it for more information, code samples, etc.

You can buy the book from Amazon by clicking the link on the right.

#+hugo: more

\nbsp

* Ideas
:PROPERTIES:
:export_hugo_section: post
:END:

Ideas for things to write about.

** TODO Using and extending Seal                               :hammerspoons:
** TODO Sending things to OmniFocus                             :hammerspoon:
** TODO ox-hugo                                                  :emacs:hugo:
** TODO CryFS                                                   :cryfs:howto:
** TODO Hosting a Hugo blog in GitHub            :hugo:github:blogging:howto:
Short guide to setting up Hugo, using /docs to host to avoid branches, and setting up your custom domain.
* Posts
:PROPERTIES:
:export_hugo_section: post
:END:

Blog posts.

** Literate config files    :config:howto:literateprogramming:literateconfig:

I group here the posts about my documented config files, which include the live files from my current configuration.

*** DONE My Emacs Configuration, With Commentary                      :emacs:
CLOSED: [2017-12-17 Sun 20:14]
:PROPERTIES:
:export_file_name: 2017-12-17-my-emacs-configuration-with-commentary
:export_hugo_custom_front_matter: :featured_image /images/emacs-logo.svg :toc true
:END:
#+begin_description
I have enjoyed slowly converting my configuration files to literate programming style using org-mode in Emacs. It's now the turn of my Emacs configuration file.
#+end_description

Last update: *{{{updatetime}}}*

I have enjoyed slowly converting my configuration files to [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming]] style style using org-mode in Emacs. I previously posted my [[file:../my-elvish-configuration-with-commentary/][Elvish configuration]], and now it's the turn of my Emacs configuration file. The text below is included directly from my [[https://github.com/zzamboni/dot_emacs/blob/master/init.org][init.org]] file. Please note that the text below is a snapshot as the file stands as of the date shown above, but it is always evolving. See the [[https://github.com/zzamboni/dot_emacs/blob/master/init.org][init.org file in GitHub]] for my current, live configuration, and the generated file at [[https://github.com/zzamboni/dot_emacs/blob/master/init.el]].

#+include: "~/.emacs.d/init.org" :lines "19-"

*** DONE My Hammerspoon Configuration, With Commentary          :hammerspoon:
CLOSED: [2018-01-08 Mon 13:31]
:PROPERTIES:
:export_file_name: 2018-01-08-my-hammerspoon-configuration-with-commentary
:export_hugo_custom_front_matter: :toc true :featured_image /images/hammerspoon.png
:END:
#+begin_description
In my ongoing series of literate config files, I present to you my Hammerspoon configuration file.
#+end_description

Last update: *{{{updatetime}}}*

In my [[file:../my-elvish-configuration-with-commentary/][ongoing]] [[file:../my-emacs-configuration-with-commentary][series]] of [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate]] config files, I present to you my [[http://www.hammerspoon.org/][Hammerspoon]] configuration file. You can see the generated file at [[https://github.com/zzamboni/dot-hammerspoon/blob/master/init.lua]]. As usual, this is just a snapshot at the time shown above, you can see the current version of my configuration [[https://github.com/zzamboni/dot-hammerspoon/blob/master/init.org][in GitHub]].

#+include: "~/.hammerspoon/init.org" :lines "19-"

*** DONE My Elvish Configuration With Commentary                     :elvish:
CLOSED: [2017-11-16 Thu 20:21]
:PROPERTIES:
:export_file_name: 2017-11-16-my-elvish-configuration-with-commentary
:export_hugo_custom_front_matter: :toc true :featured_image /images/elvish-logo.svg
:END:
#+begin_description
In this blog post I will walk you through my current Elvish configuration file, with running commentary about the different sections.
#+end_description

Last update: *{{{updatetime}}}*

In this blog post I will walk you through my current [[http://elvish.io][Elvish]] configuration file, with running commentary about the different sections.

This is also my first blog post written using [[http://orgmode.org/][org-mode]], which I have started using for writing and documenting my code, using [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming]]. The content below is included unmodified from my [[https://github.com/zzamboni/dot-elvish/blob/master/rc.org][rc.org file]] (as of the date shown above), from which the [[https://github.com/zzamboni/dot-elvish/blob/master/rc.elv][rc.elv]] file is directly generated.

Without further ado...

#+include: "~/.elvish/rc.org" :lines "19-"

** Emacs                                                              :emacs:
*** DONE Beautifying Org Mode in Emacs        :orgmode:beautifulemacs:config:
CLOSED: [2018-03-21 Wed 22:45]
:PROPERTIES:
:export_hugo_bundle: 2018-03-21-using-proportional-fonts-in-emacs-with-org-mode
:export_file_name: index
:export_hugo_custom_front_matter: :toc true :featured_image /images/emacs-logo.svg
:END:
#+begin_description
Configuring Org Mode in Emacs for beautiful typography for both text and code editing.
#+end_description

Over the last few months, I have used [[https://orgmode.org/][org-mode]] more and more for writing and programming in Emacs. I love its flexibility and power, and it is the first [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming]] tool which "feels right", and I have been able to stick with it for a longer period of time than in my previous attempts.

Recently I started thinking about how I could make my editing environment more visually appealing. I am in general very happy with my Emacs' appearance. I use the [[https://github.com/Greduan/emacs-theme-gruvbox][Gruvbox theme]], and org-mode has very decent syntax highlighting. But as I write more and more prose in Emacs these days, I started thinking it might be nice to edit text in more visually-appealing fonts, including using a proportional font, which makes regular prose much more readable. I would like to share with you what I learned and my current Emacs configuration.

In the end, you can have an Emacs setup for editing org documents which looks very nice, with proportional fonts for text and monospaced fonts for code blocks, examples and other elements. To wet your appetite, here is what a fragment of my [[https://github.com/zzamboni/dot-emacs/blob/master/init.org][init.org]] file looks like:

[[file:images/emacs-init-propfonts.png][file:images/emacs-init-propfonts.png]]

**** Step 1: Configure faces for Org headlines and lists

My first step was to make  org-mode much more readable by using different fonts for headings, hiding some of the markup, and improving list bullets. I took these settings originally from Howard Abrams' excellent [[http://www.howardism.org/Technical/Emacs/orgmode-wordprocessor.html][Org as a Word Processor]] article, although I have tweaked them a bit.

First, we ask org-mode to hide the emphasis markup (e.g. =/.../= for italics, =*...*= for bold, etc.):

#+begin_src emacs-lisp :tangle no
  (setq org-hide-emphasis-markers t)
#+end_src

Then, we set up a font-lock substitution for list markers (I always use "=-=" for lists, but you can change this if you want) by replacing them with a centered-dot character:

#+begin_src emacs-lisp :tangle no
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

The =org-bullets= package replaces all headline markers with different Unicode bullets:

#+begin_src emacs-lisp :tangle no
  (use-package org-bullets
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+end_src

Finally, we set up a nice proportional font, in different sizes, for the headlines. The fonts listed will be tried in sequence, and the first one found will be used. Feel free to add your own favorite font:

#+begin_src emacs-lisp :tangle no
  (let* ((variable-tuple
          (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
                ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
                ((x-list-fonts "Verdana")         '(:font "Verdana"))
                ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
         (base-font-color     (face-foreground 'default nil 'default))
         (headline           `(:inherit default :weight bold :foreground ,base-font-color)))

    (custom-theme-set-faces
     'user
     `(org-level-8 ((t (,@headline ,@variable-tuple))))
     `(org-level-7 ((t (,@headline ,@variable-tuple))))
     `(org-level-6 ((t (,@headline ,@variable-tuple))))
     `(org-level-5 ((t (,@headline ,@variable-tuple))))
     `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
     `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
     `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
     `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
     `(org-document-title ((t (,@headline ,@variable-tuple :height 2.0 :underline nil))))))
#+end_src

**** Step 2: Setting up =variable-pitch= and =fixed-pitch= faces

My next realization was that Emacs already includes support for displaying proportional fonts with the =variable-pitch-mode= command. You can try it right now: type ~M-x~ =variable-pitch-mode= and your current buffer will be shown in a proportional font (you can disable it by running =variable-pitch-mode= again). On my Mac the default variable-pitch font is Helvetica. You can change the font used by configuring the =variable-pitch= face. You can do this interactively through the customize interface by typing ~M-x~ =customize-face= =variable-pitch=. At the moment I like [[https://en.wikipedia.org/wiki/Source_Sans_Pro][Source Sans Pro]].

As a counterpart to =variable-pitch=, you need to configure the =fixed-pitch= face for the text that needs to be shown in a monospaced font. My first instinct was to inherit this from my =default= face (I use [[https://en.wikipedia.org/wiki/Inconsolata][Inconsolata]]), but it seems that this gets remapped when =variable-pitch-mode= is active, so I had to configure it by hand with the same font as my =default= face.

What I would suggest is that you customize the fonts interactively, as you can see live how it looks on your text. You can make the configuration permanent from the customize screen as well. If you want to explicitly set them in your configuration file, you can do it with the =custom-theme-set-faces= function, like this:

#+begin_src emacs-lisp
  (custom-theme-set-faces
   'user
   '(variable-pitch ((t (:family "Source Sans Pro" :height 180 :weight light))))
   '(fixed-pitch ((t ( :family "Inconsolata" :slant normal :weight normal :height 1.0 :width normal)))))
#+end_src

*Tip:* you can get the LISP expression for your chosen font (the part that looks like =((t (:family ... )))= from the =customize-face= screen - open the "State" button and choose the "Show Lisp Expression" menu item.

You can enable =variable-pitch-mode= automatically for org buffers by setting up a hook like this:

#+begin_src emacs-lisp :tangle no
  (add-hook 'org-mode-hook 'variable-pitch-mode)
#+end_src

**** Step 2: Use long lines and =visual-line-mode=

One thing you will notice right away with proportional fonts is that filling paragraphs no longer makes sense. This is because =fill-paragraph= works based on the number of characters in a line, but with a proportional font, characters have different widths, so a filled paragraph looks strange:

[[file:images/emacs-filled-paragraph.png][file:images/emacs-filled-paragraph.png]]

Of course, you can still do it, but there's a better way. With =visual-line-mode= enabled, long lines will flow and adjust to the width of the window. This is great for writing prose, because you can choose how wide your lines are by just resizing your window.

[[file:images/emacs-narrow-window.png][file:images/emacs-narrow-window.png]]

[[file:images/emacs-wide-window.png][file:images/emacs-wide-window.png]]

There is one habit you have to change for this to work: the instinct (at least for me) of pressing ~M-q~ every once in a while to readjust the current paragraph. I personally think it's worth it.

You can enable =visual-line-mode= automatically for org buffers by setting up another hook:

#+begin_src emacs-lisp :tangle no
  (add-hook 'org-mode-hook 'visual-line-mode)
#+end_src

**** Step 4: Configure faces for specific Org elements

After all the changes above, you will have nice, proportional fonts in your Org buffers. However, there are some things for which you still want monospace fonts! Things like source blocks, examples, tags and some other markup elements still look better in a fixed-spacing font, in my opinion. Fortunately, org-mode has an extremely granular face selection, so you can easily customize them to have different elements shown in the correct font, color, and size.

*Tip:* you can use ~C-u~ ~C-x~ ~=~ (which runs the command =what-cursor-position= with a prefix argument) to show information about the character under the cursor, including the face which is being used for it. If you find a markup element which is not correctly configured, you can use this to know which face you have to customize.

You can configure specific faces any way you want, but if you simply want them to be rendered in monospace font, you can set them to inherit from the =fixed-pitch= face we configured before. You can also inherit from multiple faces to combine their attributes.

Here are the faces I have configured so far (there are probably many more to do, but I don't use org-mode to its full capacity yet). I'm showing here the LISP expressions, but you can just as well configure them using =customize-face=.

#+begin_src emacs-lisp
  (custom-theme-set-faces
   'user
   '(org-block                 ((t (:inherit fixed-pitch))))
   '(org-document-info         ((t (:foreground "dark orange"))))
   '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
   '(org-link                  ((t (:foreground "royal blue" :underline t))))
   '(org-meta-line             ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-property-value        ((t (:inherit fixed-pitch))) t)
   '(org-special-keyword       ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-tag                   ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
   '(org-verbatim              ((t (:inherit (shadow fixed-pitch))))))
#+end_src

One minor issue I have noticed is that, in =variable-pitch-mode=, the fixed-pitch blocks have a slight increase in inter-line spacing. This is not a deal breaker for me, but it is a noticeable difference. This can be observed in the following screenshot, which shows the block of code above embedded in the org-mode buffer and in the block-editing buffer, which uses the fixed-width font. If you know a way in which this could be fixed, please let me know!

[[file:images/emacs-differing-heights.png][file:images/emacs-differing-heights.png]]

**** Conclusion

The setup described above has considerably improved my enjoyment of writing in Emacs. I hope you find it useful. If you have any feedback, suggestions or questions, please let me know in the comments.

** Hammerspoon                                                  :hammerspoon:
** Elvish                                                            :elvish:
:PROPERTIES:
:export_hugo_custom_front_matter: :featured_image /images/elvish-logo.svg
:END:

*** DONE Bang-Bang (!!, !$) Shell Shortcuts in Elvish     :shell:unix:config:
CLOSED: [2017-12-04 Mon 22:15]
:PROPERTIES:
:export_file_name: 2017-12-04-bang-bang-shortcuts-in-elvish
:END:
#+begin_description
How to set up the bash !! and !$ shortcuts for accessing the previous command in Elvish.
#+end_description

(Updated on March 19th, 2018 to use the new [[https://elvish.io/ref/epm.html][Elvish Package Manager]])

The bash shortcuts (maybe older? I'm not sure in which shell these originated) for "last command" (=!!=) and "last argument of last command" (=!$=) are, for me at least, among the most strongly imprinted in my muscle memory, and I use them all the time. Although these shortcuts are not available in [[file:/post/elvish-an-awesome-unix-shell/][Elvish]] by default, they are easy to implement. I have written a module called [[https://github.com/zzamboni/elvish-modules/blob/master/bang-bang.org][bang-bang]] which you can readily use as follows:

- Use [[https://elvish.io/ref/epm.html][epm]] to install my elvish-modules package (you can also add this to your =rc.elv= file to have the package installed automatically if needed):

  #+begin_src elvish
    use epm
    epm:install github.com/zzamboni/elvish-modules
  #+end_src

- In your =rc.elv= (see [[file:/post/my-elvish-configuration-with-commentary/][mine]] as an example), add the following to load the =bang-bang= module and to set up the appropriate keybindings:

  #+begin_src elvish
    use github.com/zzamboni/elvish-modules/bang-bang
  #+end_src

That's it! Start a new shell window, and test how command-history mode can be invoked by the =!= key. Assuming your last command was =ls -l ~/.elvish/rc.elv=, when you press =!= you will see the following:

#+begin_example
  bang-lastcmd [A C] _
  ! ls -l .elvish/rc.elv
  0 ls
  1 -l
  2/$ .elvish/rc.elv
  Alt-! !
#+end_example

If you press =!= again, the whole last command will be inserted. If you press =$= (or =2=), only the last argument will be inserted. You can insert any other component of the previous command using its corresponding number. If you want to insert an exclamation sign, you can press =Alt-!=.

Note that by default, =Alt-!= will also be bound to trigger this mode, so you can fully replace the default [[https://elvish.io/learn/cookbook.html]["last command" mode]] in Elvish.

Have fun with Elvish!
*** DONE Using and writing completions in Elvish :shell:completions:unix:config:
CLOSED: [2018-06-13 Wed 20:25]
:PROPERTIES:
:export_file_name: 2018-06-13-using-and-writing-completions-in-elvish
:export_hugo_custom_front_matter: :toc true :featured_image /images/elvish-logo.svg
:END:
#+begin_description
Like other Unix shells, Elvish has advanced command-argument completion capabilities. In this article I will explore the existing completions, and show you how you can create your own (and contribute them back to the community!)
#+end_description

Like other Unix shells, [[https://elvish.io/][Elvish]] has advanced command-argument completion capabilities. In this article I will explore the existing completions, and show you how you can create your own (and contribute them back to the community).

**** Using existing completions

There is a growing body of shell completions that you can simply load and use.

Elvish has a still-small but growing collection of completions that have been created by its users. These are a few that I know of (let me know if you know others!):

- My own [[https://github.com/zzamboni/elvish-completions][zzamboni/elvish-completions]] package, which contains completions for [[https://github.com/zzamboni/elvish-completions/blob/master/git.org][git]] (providing automatically-generated completions for all commands and their options, plus hand-crafted argument completions for many of them), [[https://github.com/zzamboni/elvish-completions/blob/master/ssh.org][ssh]], [[https://github.com/zzamboni/elvish-completions/blob/master/vcsh.org][vcsh]], [[https://github.com/zzamboni/elvish-completions/blob/master/cd.org][cd]], and a few of Elvish's [[https://github.com/zzamboni/elvish-completions/blob/master/builtins.org][built-in functions and modules]]. It also contains [[https://github.com/zzamboni/elvish-completions/blob/master/comp.org][comp]], a framework for building completers, which we will explore in more detail below. To use any of these modules, you just need to install the elvish-completions package, and then load the modules you want. For example:
  #+begin_src elvish
    epm:install &silent-if-installed github.com/zzamboni/elvish-completions
    use github.com/zzamboni/elvish-completions/vcsh
    use github.com/zzamboni/elvish-completions/cd
    use github.com/zzamboni/elvish-completions/ssh
    use github.com/zzamboni/elvish-completions/builtins
    use github.com/zzamboni/elvish-completions/git
  #+end_src
- xiaq's [[https://github.com/xiaq/edit.elv/blob/master/compl/go.elv][edit.elv/compl/go.elv]], which provides extensive hand-crafted completions for =go=. You can also install this one as an Elvish package:
  #+begin_src elvish
    epm:install &silent-if-installed github.com/xiaq/edit.elv
    use github.com/xiaq/edit.elv/compl/go
    go:apply
  #+end_src
- occivink's [[https://github.com/occivink/config/blob/master/.elvish/lib/completers.elv][completers.elv]] file, which contains completers for =kak=, =ssh=, =systemctl=, =ffmpeg= and a few other commands.
- Tw's [[https://github.com/tw4452852/MyConfig/tree/master/config/.elvish/lib/completer][completer/]] files, which contains completions for =adb=, =git= and =ssh=.
- SolitudeSF's [[https://github.com/SolitudeSF/dot/blob/master/elvish/lib/completers.elv][completers.elv]] file, which contains completers for =cd=, =kak=, =kitty=, =git=, =man=, =pkill= and quite a few other commands.

As of this writing, there is no "official" collection of Elvish completions, so feel free to look at the existing ones and choose/use the ones that work best for you.

Since the collection is not yet very big, it's likely you will want to build your own completions. This is what the next section is about.

**** Creating your own completions

Elvish has a simple but powerful argument-completion mechanism. You can find the full documentation [[https://elvish.io/ref/edit.html#completion-api][in the Elvish reference]], but let's take a quick look here.

***** Basic (built-in) argument completion mechanisms

Command argument completion in Elvish is implemented by functions stored inside =$edit:completion:arg-completer=. This variable is a map in which the indices are command names, and the values are functions which must receive a variable number of arguments. When the user types =cat= ~Space~ ~Tab~, the function stored in =$edit:completion:arg-completer[cat]= (if any) is called, as follows:

#+begin_src elvish
  $edit:completion:arg-completer[cat] cat ''
#+end_src

The function receives the full current command line as arguments, including the current argument, which might be empty as in the example above, or be a partially typed string. For example, if the user types =cat f= ~Tab~, the completer function will be called like this:

#+begin_src elvish
  $edit:completion:arg-completer[cat] cat 'f'
#+end_src

The completion function must use its arguments to determine the appropriate completions at that point, and return them by one of the following methods (which can be combined):

- Output the completions to stdout, one per line;
- Output the completions to the data stream (using =put=);
- Output the completions using the =edit:complex-candidate= command, which can additionally specify a suffix to append to the completion in the completion menu or in the returned value, and a style to use (as accepted by =edit:styled=). The full syntax of =edit:complex-candidate= is as follows:
  #+begin_src elvish
    edit:complex-candidate &code-suffix='' &display-suffix='' &style='' $string
  #+end_src
  =$string= is the option to display; =&code-suffix= indicates a suffix to be appended to the completion string when the user selects it; =&display-suffix= indicates a suffix to be shown in the completion menu (but which is not returned as part of the completion); and =&style= indicates a text style to use in the completion menu.

Keep in mind that the options returned by the completion function are additionally filtered by what the user has typed so far. This means that the last argument can usually be ignored, since Elvish will automatically do the filtering. An exception to this is if you want to return different /types of things/ depending on what the user has typed already. For example, if the last argument start with =-=, you may want to return the possible command-line options, and return regular argument completions otherwise.

*Example #1:* A very simple completer for the =brew= command:

#+begin_src elvish
  edit:completion:arg-completer[brew] = [@cmd]{
    len = (count $cmd)
    if (eq $len 2) {
      if (has-prefix $cmd[-1] -) {
        put '--version' '--verbose'
      } else {
        put install uninstall
      }
    } elif (eq $len 3) {
      brew search | eawk [l @f]{ put $@f }
    }
  }
#+end_src

If the function receives two arguments, we check to see if the last argument begins with a dash. If so, we return the possible command-line options, otherwise we return the two commands =install= and =uninstall=. If we receive three arguments (i.e. we are past the initial command), we return the list of possible packages to install or uninstall.

You may noticed that there are many cases that this simple function does not handle correctly. For example, if you type =brew --verbose= ~Space~ ~Tab~, you get the list of packages as completion, which does not make sense at that point. We will look at more complex and complete completion functions next.

The first step to more complex completions is the =edit:complete-getopt= command, which allows us to specify a sequence of positional completion functions. The general syntax of the command is:

#+begin_src elvish
  edit:complete-getopt $args $opts $handlers
#+end_src

Please see [[https://elvish.io/ref/edit.html#editcomplete-getopt][its documentation]] for a full description of the arguments.

*Example #2:* The completer for =brew= shown before can be specified like this:

#+begin_src elvish
  edit:completion:arg-completer[brew] = [@cmd]{
    edit:complete-getopt $cmd[1:] \
    [[&long=version] [&long=verbose]] \
    [
      [_]{ put install uninstall }
      [_]{ brew search | eawk [_ @f]{ put $@f } }
      ...
    ]
  }
#+end_src

This new completer overcomes a few of the limitations in our previous attempt. For one, the =install= and =uninstall= commands are now properly completed even if you specify options before. Furthermore, the =...= at the end of the handler list indicates that the previous one (the package names) will be repeated for all further arguments - this makes it possible to complete multiple package names to install or uninstall. However, it still has some limitations! For example, it will give you all existing packages as possible arguments to =uninstall=, which only accepts already installed packages.

In addition to =complete-getopt=, Elvish includes a few other functions to help build completers:

- =edit:complete-filename= produces a listing of all the files and directories in the directory of its argument, and is the default completion function when no other completer is specified. See its [[https://elvish.io/ref/edit.html#editcomplete-filename][documentation]] for full details.
- =edit:complete-sudo= provides completions for commands like =sudo= which take a command as their first argument. It is the default completer for the =sudo= command, so that if you type =sudo= ~Space~ ~Tab~, you get a list of all the commands on your execution path. It can be reused for other commands, for example =time=:
  #+begin_src elvish
    edit:completion:arg-completer[time] = $edit:complete-sudo~
  #+end_src

Finally, note that if =$edit:completion:arg-completer['']= exists, it will be called as a fall-back completer if no command-specific argument completer exists. You can see that the default completer is =edit:complete-filename=, as mentioned before:

#+begin_src elvish
  ~> put $edit:completion:arg-completer['']
  ▶ $edit:complete-filename~
#+end_src

With the tools you know so far, you can already create fairly complex completers. In the next section, we will explore =comp=, an external library I wrote to make it easier to specify complex completion trees.

***** Complex completions using the =comp= framework

The built-in completion functions make it possible to build any completer you want. However, you might realize that for more complex cases, the specifications can be quite complex. For this reason, I wrote [[https://github.com/zzamboni/elvish-completions/blob/master/comp.org][the =comp= library]] as a framework to more easily specify completion functions. The basic Elvish mechanisms and functions are still used in the backend, so you can rest assured about their compatibility with the basic mechanisms.

As a first step, if you haven't done so already, you should install the =elvish-completions= package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish
  use epm
  epm:install github.com/zzamboni/elvish-completions
#+end_src

From the file where you will define your completions (or from your interactive session if you just want to play with it), load the =comp= module:

#+begin_src elvish
  use github.com/zzamboni/elvish-completions/comp
#+end_src

The main entry points for this module are =comp:item=, =comp:sequence= and =comp:subcommands=. Each one receives a single argument containing a  "completion definition", which indicates how the completions will be produced. Each one receives a different kind of completion structure, and returns a ready-to-use completion function, which can be assigned directly to an element of =$edit:completion:arg-completer=. A simple example:

#+begin_src elvish
  edit:completion:arg-completer[foo] = (comp:item [ bar baz ])
#+end_src

If you type this in your terminal, and then type =foo<space>= and press ~Tab~, you will see the appropriate completions:

#+begin_example
  > foo <Tab>
   COMPLETING argument _
   bar  baz
#+end_example

To create completions for new commands, your main task is to define the corresponding completion definition. The different types of definitions and functions are explained below, with examples of the different available structures and features.

*Note:* the main entry points return a ready-to-use argument handler function. If you ever need to expand a completion definition directly (maybe for some advanced usage), you can call =comp:-expand-item=, =comp:-expand-sequence= and =comp:-expand-subcommands=, respectively. These functions all take the definition structure and the current command line, and return the appropriate completions at that point.

We now look at the different types of completion definitions understood by =comp=.

****** Items

The base building block is the "item", can be one of the following:

- An array containing all the potential completions (it can be empty, in which case no completions are provided). This is useful for providing a static list of completions.
- A function which returns the potential completions (it can return nothing, in which case no completions are provided). The function should have one of the following arities, which affect which arguments will be passed to it (other arities are not valid, and in that case the item will not be executed):
  - If it takes no arguments, no arguments are passed to it.
  - If it takes a single argument, it gets the current (last) component of the command line =@cmd=; this is just like the handler functions understood by the =edit:complete-getopt= command.
  - If it takes a rest argument, it gets the full current command line (the contents of =@cmd=); this is just like the functions assigned to =$edit:completion:arg-completer=.

*Example #3:* a simple completer for =cd=

In this case, we define a function which receives the current "stem" (the part of the filename the user has typed so far) and offers all the relevant files, then filters those which are directories, and returns them as completion possibilities. We pass the function directly as a completion item to =comp:-expand=.

#+begin_src elvish
  fn complete-dirs [arg]{ put {$arg}* | each [x]{ if (-is-dir $x) { put $x } } }
  edit:completion:arg-completer[cd] = (comp:item $complete-dirs~)
#+end_src

For file and directory completion, you can use the utility function =comp:files= instead of defining your own function (see [[*Utility functions][Utility functions]]). =comp:files= uses =edit:complete-filename= in the backend but offers a few additional filtering options:

#+begin_src elvish
  edit:completion:arg-completer[cd] = (comp:item [arg]{ comp:files $arg &dirs-only })
#+end_src

****** Sequences and command-line options

Completion items can be aggregated in a /sequence of items/ and used with the =comp:sequence= function when you need to provide different completions for different positional arguments of a command, including support for command-line options at the beginning of the command (=comp:sequence= uses =edit:complete-getopt= in the backend, but provides a few additional convenient features). The definition structure in this case has to be an array of items, which will be applied depending on their position within the command parameter sequence. If the the last element of the list is the string =...= (three periods), the next-to-last element of the list is repeated for all later arguments. If no completions should be provided past the last argument, simply omit the periods. If a sequence should produce no completions at all, you can use an empty list =[]=. If any specific elements of the sequence should have no completions, you can specify ={ comp:empty }= or =[]= as its value.

If the =&opts= option is passed to the =comp:sequence= function, it must contain a single definition item which produces a list of command-line options that are allowed at the beginning of the command, when no other arguments have been provided. Options can be specified in either of the following formats:
- As a string which gets converted to a long-style option; e.g. =all= to specify the =--all= option. The string must not contain the dashes at the beginning.
- As a map in the style of =complete-getopt=, which may contain the following keys:
  - =short= for the short one-letter option;
  - =long= for the long-option string;
  - =desc= for a descriptive string which gets shown in the completion menu;
  - =arg-mandatory= or =arg-optional=: either one but not both can be set to =$true= to indicate whether the option takes a mandatory or optional argument;
  - =arg-completer= can be specified to produce completions for the option argument. If specified, it must contain completion item as described in [[*Items][Items]], and which will be expanded to provide completions for that argument's values.

Simple example of a completion data structure for option =-t= (long form =--type=), which has a mandatory argument which can be =elv=, =org= or =txt=:

#+begin_example
  [ &short=t
    &long=type
    &desc="Type of file to show"
    &arg-mandatory=$true
    &arg-completer= [ elv org txt ]
  ]
#+end_example

*Note:* options are only offered as completions when the use has typed a dash as the first character. Otherwise the argument completers are used.

*Example #4:* we can improve on the previous completer for =cd= by preventing more than one argument from being completed (only the first argument will be completed using =complete-dirs=, since the list does not end with =...=):

#+begin_src elvish
  edit:completion:arg-completer[cd] = (comp:sequence [ [arg]{ comp:files $arg &dirs-only }])
#+end_src

*Example #5:* a simple completer for =ls= with a subset of its options. Note that =-l= and =-R= are only provided as completions when you have not typed any filenames yet. Also note that we are using [[*Utility functions][comp:files]] to provide the file completions, and the =...= at the end of the sequence to use the same completer for all further elements.

#+begin_src elvish
  ls-opts = [
    [ &short=l                 &desc='use a long listing format' ]
    [ &short=R &long=recursive &desc='list subdirectories recursively' ]
  ]
  edit:completion:arg-completer[ls] = (comp:sequence &opts=$ls-opts [ $comp:files~ ... ])
#+end_src

*Example #6:* See the [[https://github.com/zzamboni/elvish-completions/blob/master/ssh.org][ssh completer]] for a real-world example of using sequences.

****** Subcommands

Finally, completion sequences can be aggregated into /subcommand structures/ using the =comp:subcommands= function, to provide completion for commands such as =git=, which accept multiple subcommands, each with their own options and completions. In this case, the definition is a map indexed by subcommand names. The value of each element can be a =comp:item=,  a =comp:sequence= or another =comp:subcommands= (to provide completion for sub-sub-commands, see the example below for =vagrant=). The =comp:subcommands= function can also receive the =&opts= option to generate any available top-level options.

*Example #7:* let us reimplement our completer for the =brew= package manager, but now with support for the =install=, =uninstall= and =cat= commands. =install= and =cat= gets as completions all available packages (the output of the =brew search= command), while =uninstall= only completes installed packages (the output of =brew list=). Note that for =install= and =uninstall= we automatically extract command-line options from their help messages using the =comp:extract-opts= function (wrapped into the =-brew-opts= function), and pass them as the =&opts= option in the corresponding sequence functions. Also note that all =&opts= elements get initialized at definition time (they are arrays), whereas the sequence completions get evaluated at runtime (they are lambdas), to automatically update according to the current packages. The =cat= command sequence allows only one option. The load-time initialization of the options incurs a small delay, and you could replace these with lambdas as well so that the options are computed at runtime. Note also the usage of the =comp:decorate= function to colorize the package names in different colors for each command.

#+begin_src elvish
  fn -brew-opts [cmd]{
    brew $cmd -h | take 1 | \
    comp:extract-opts &regex='--(\w[\w-]*)' &regex-map=[&long= 1]
  }
  brew-completions = [
    &install= (comp:sequence &opts= [ (-brew-opts install) ] \
      [ { brew search | comp:decorate &style=green } ... ]
    )
    &uninstall= (comp:sequence &opts= [ (-brew-opts uninstall) ] \
      [ { brew list | comp:decorate &style=red }   ... ]
    )
    &cat= (comp:sequence [{ brew search | comp:decorate &style=blue }])
  ]
  edit:completion:arg-completer[brew] = (comp:subcommands \
    &opts= [ version verbose ] $brew-completions
  )
#+end_src

Note that in contrast to our previous =brew= completer, this definition is much more expressive, accurate, and much easier to extend.

*Example #8:* a simple completer for a subset of =vagrant=, which receives commands which may have subcommands and options of their own. Note that the value of =&up= is a =comp:sequence=, but the value of =&box= is another =comp:subcommands= which includes the completions for =box add= and =box remove=. Also note the use of the =comp:extract-opts= function to extract the command-line arguments automatically from the help messages. The output of the =vagrant= help messages matches the default format expected by =comp:extract-opts=, so we don't even have to specify a regular expression like for =brew=.

*Tip:* note that the values of =&opts= are functions (e.g. ={ vagrant-up -h | comp:extract-opts }=) instead of arrays (e.g. =( vagrant up -h | comp:extract-opts )=). As mentioned in the previous example, both are valid, but in the latter case they are all initialized at load time (when the data structure is defined), which might introduce a delay, particularly with more command definitions. By using functions the options are only extracted at runtime when the completion is requested. For further optimization, =vagrant-opts= could be made to memoize the values so that the delay only occurs the first time.

#+begin_src elvish
  vagrant-completions = [
    &up= (comp:sequence [] \
      &opts= { vagrant up -h | comp:extract-opts }
    )
    &box= (comp:subcommands [
        &add= (comp:sequence [] \
          &opts= { vagrant box add -h | comp:extract-opts }
        )
        &remove= (comp:sequence [ { \
              vagrant box list | eawk [_ @f]{ put $f[0] } \
          } ... ] \
          &opts= { vagrant box remove -h | comp:extract-opts }
        )
  ])]

  edit:completion:arg-completer[vagrant] = (comp:subcommands \
    &opts= [ version help ] $vagrant-completions
  )
#+end_src

*Example #9:* See the [[https://github.com/zzamboni/elvish-completions/blob/master/git.org][git completer]] for a real-world subcommand completion example, which also shows how extensively auto-population of subcommands and options can be done by extracting information from help messages.

****** Utility functions

The =comp= module includes a few utility functions, some of which you have seen already in the examples.

=comp:decorate= maps its input through =edit:complex-candidate= with the given options. Can be passed the same options as [[https://elvish.io/ref/edit.html#argument-completer][edit:complex-candidate]]. In addition, if =&suffix= is specified, it is used to set both =&display-suffix= and =&code-suffix=. Input can be given either as arguments or through the pipeline:

#+begin_src elvish
  > comp:decorate &suffix=":" foo bar
  ▶ (edit:complex-candidate foo &code-suffix=: &display-suffix=: &style='')
  ▶ (edit:complex-candidate bar &code-suffix=: &display-suffix=: &style='')
  > put foo bar | comp:decorate &style="red"
  ▶ (edit:complex-candidate foo &code-suffix='' &display-suffix='' &style=31)
  ▶ (edit:complex-candidate bar &code-suffix='' &display-suffix='' &style=31)
#+end_src

=comp:extract-opts= takes input from the pipeline and extracts command-line option data structures from its output. By default it understand the following common formats:

#+begin_example
  -o, --option                Option description
  -p, --print[=<what>]        Option with an optional argument
      --select <type>         Option with a mandatory argument
#+end_example

Typical use would be to populate an =&opts= element with something like this:

#+begin_src elvish
  comp:sequence &opts= { vagrant -h | comp:extract-opts } [ ... ]
#+end_src

The regular expression used to extract the options can be specified with the =&regex= option. Its default value (which parses the common formats shown above) is:

#+begin_src elvish :noweb-ref opt-capture-regex
  &regex='^\s*(?:-(\w),?\s*)?(?:--?([\w-]+))?(?:\[=(\S+)\]|[ =](\S+))?\s*?\s\s(\w.*)$'
#+end_src

The mapping of capture groups from the regex to option components is defined by the =&regex-map= option. Its default value (which also shows the available fields) is:

#+begin_src elvish :noweb-ref opt-capture-map
  &regex-map=[&short=1 &long=2 &arg-optional=3 &arg-mandatory=4 &desc=5]
#+end_src

At least one of =short= or =long= must be present in =regex-map=. The =arg-optional= and =arg-mandatory= groups, if present, are handled specially: if any of them is not empty, then its contents is stored as =arg-desc= in the output, and the corresponding =arg-mandatory= / =arg-optional= is set to =$true=.

If =&fold= is =$true=, then the input is preprocessed to join option descriptions which span more than one line (the heuristic is not perfect and may not work in all cases, also for now it only joins one line after the option).

**** Contributing your completions


So you have created a brand-new completion function and would like to share it with the Elvish community. Nothing could be easier! You have two main options:

- Publish them on your own. For example, if you put your =.elv= files into their own repository in GitHub or Gitlab, they are ready to be installed and used using [[https://elvish.io/ref/epm.html][epm]].
- Contribute it to an existing repository (for example [[https://github.com/zzamboni/elvish-completions][elvish-completions]]). Just add your files, submit a pull request, and you are done.

I hope you have found this tutorial useful. Please let me know in the comments if you have any questions, feedback or if you find something that is incorrect.

Now, go have fun with Elvish!

** Other

*** TODO My blogging workflow with Emacs, org-mode+ox-hugo, Hugo and GitHub :blogging:howto:emacs:hugo:orgmode:github:


* Footnotes
* COMMENT Local Variables                                           :ARCHIVE:
# Local Variables:
# eval: (add-hook 'after-save-hook #'org-hugo-export-wim-to-md-after-save :append :local)
# End:
