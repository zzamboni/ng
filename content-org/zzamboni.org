#+hugo_base_dir: ../
#+seq_todo: TODO DRAFT DONE
#+options: creator:t
#+property: header-args :eval never-export
#+hugo_front_matter_key_replace: description>summary

#+macro: updatetime {{{time(%B %e\, %Y)}}}

# The zz/* functions used in the macros are defined in my Emacs configuration:
# https://github.com/zzamboni/dot-emacs/blob/master/init.org
#+macro: hsapi (eval (zz/org-macro-hsapi-code $1 $2 $3))
#+macro: keys (eval (zz/org-macro-keys-code $1))
#+macro: luadoc (eval (zz/org-macro-luadoc-code $1 $2 $3))
#+macro: luafun (eval (zz/org-macro-luafun-code $1 $2))
#+macro: spoon [[http://www.hammerspoon.org/Spoons/$1][$1]]

#+title: zzamboni.org source file
#+author: Diego Zamboni
#+email: diego@zzamboni.org

This file is the source for all new and updated content on [[http://zzamboni.org/][my website]] since March 2018. Content here may be in progress or incomplete. This file gets converted to [[http://gohugo.io/][Hugo]] files by the excellent [[https://ox-hugo.scripter.co/][ox-hugo]].

*You really should not read it here but at [[http://zzamboni.org/][zzamboni.org]]*.

* Table of Contents                                          :TOC_3:noexport:
- [[#pages][Pages]]
  - [[#about][About]]
    - [[#my-online-past][My online past]]
    - [[#about-this-site][About this site]]
    - [[#image-attributions][Image attributions:]]
  - [[#contact][Contact]]
  - [[#books][Books]]
- [[#book-pages][Book pages]]
  - [[#learning-cfengine-3][Learning CFEngine 3]]
- [[#ideas][Ideas]]
  - [[#using-and-extending-seal][Using and extending Seal]]
  - [[#sending-things-to-omnifocus][Sending things to OmniFocus]]
  - [[#ox-hugo][ox-hugo]]
  - [[#cryfs][CryFS]]
  - [[#hosting-a-hugo-blog-in-github][Hosting a Hugo blog in GitHub]]
- [[#posts][Posts]]
  - [[#literate-config-files][Literate config files]]
    - [[#my-emacs-configuration-with-commentary][My Emacs Configuration, With Commentary]]
    - [[#my-hammerspoon-configuration-with-commentary][My Hammerspoon Configuration, With Commentary]]
    - [[#my-elvish-configuration-with-commentary][My Elvish Configuration With Commentary]]
  - [[#emacs][Emacs]]
    - [[#beautifying-org-mode-in-emacs][Beautifying Org Mode in Emacs]]
  - [[#hammerspoon][Hammerspoon]]
    - [[#getting-started-with-hammerspoon][Getting Started With Hammerspoon]]
    - [[#using-spoons-in-hammerspoon][Using Spoons in Hammerspoon]]
  - [[#elvish][Elvish]]
    - [[#bang-bang---shell-shortcuts-in-elvish][Bang-Bang (!!, !$) Shell Shortcuts in Elvish]]
    - [[#using-and-writing-completions-in-elvish][Using and writing completions in Elvish]]
  - [[#other][Other]]
    - [[#my-blogging-workflow-with-emacs-org-modeox-hugo-hugo-and-github][My blogging workflow with Emacs, org-mode+ox-hugo, Hugo and GitHub]]
- [[#footnotes][Footnotes]]

* Pages

This section contains all the static pages.

** DONE About
CLOSED: [2018-03-22 Thu 19:40]
:PROPERTIES:
:export_hugo_section: about
:export_hugo_custom_front_matter: :featured_image /images/legoland.jpg
:export_hugo_weight: 06
:export_file_name: _index
:export_hugo_aliases: /about.html
:END:

*Who:* I am a computer scientist, consultant, programmer, sysadmin, author and overall geek, now turned project leader and engineering team manager. I am from Mexico but live in Switzerland with my awesome wife and our two beautiful daughters.

*What:* I work as the lead of a development team in the Cloud Platform Division of [[http://swisscom.com/][Swisscom]], where I am applying my experience and background in security, configuration management, cloud computing and automation to build the next-generation cloud infrastructure for Swisscom and its customers. I am also the author of [[http://cf-learn.info]["Learning CFEngine 3"]].

*Where:* I was born in Argentina, but have moved around all my life.  When I was very young I moved to Mexico, where I lived in four different cities before moving to the U.S. to pursue my Ph.D. at [[http://www.cerias.purdue.edu/][Purdue University]] under the direction of [[http://spaf.cerias.purdue.edu/][Gene Spafford]]. Upon finishing my studies, my wife and I decided to go to Switzerland, where I worked at the [[http://www.zurich.ibm.com/][IBM Zurich Research Lab]]. Eight years and two kids later, we [[file:/brt/2009/09/08/going-home/index.html][moved to Mexico]] in late 2009. In 2015, we moved back to Switzerland.

*Long version:* If you are interested, here's my [[file:/vita.html][curriculum vitae]]. For other useless trivia about me, see [[http://www.zzamboni.org/brt/2007/03/07/blog-tagged/index.html][here]].

*** My online past

- 2009-2016: During this time my blog went through several iterations, hosted/powered by [[http://www.posterous.com/][Posterous]], [[https://jekyllrb.com/][Jekyll]], [[http://octopress.org/][Octopress]], [[https://postach.io/site][Postach.io]] and [[https://github.com/zzamboni/enwrite][Enwrite]]. All blog entries from this period have been merged into [[file:/post][my current blog]];
- 2005-2009: My blog titled [[file:/brt][BrT]], powered mainly by a self-hosted [[https://wordpress.org/][Wordpress]], with some intermixed use of Posterous. What you find at the link is a static archive copy;
- 1997-2001: My hand-maintained [[http://homes.cerias.purdue.edu/~zamboni/][web page at Purdue University]].

*** About this site

This entire site is generated by [[http://gohugo.io][Hugo]] and served by [[http://github.com/][GitHub]] through the incredibly useful [[http://pages.github.com/][GitHub Pages]] feature.

Both the source and the generated website are stored in the [[https://github.com/zzamboni/zzamboni.org][zzamboni/zzamboni.org]] GitHub repository, which is devoted to this content.  Recently I started using [[https://ox-hugo.scripter.co/][ox-hugo]] to generate the content from [[https://github.com/zzamboni/zzamboni.org/blob/master/content-org/zzamboni.org][a single source file]] in [[https://orgmode.org/][org-mode]] format, although all the older articles and pages are still stored in their original source Markdown files (I gradually convert them whenever I update them). Some of my [[file:/code][project]] pages are stored in the =gh-pages= branch of their own github repositories. Since GitHub Pages supports custom domains, all of them can be transparently hosted under the zzamboni.org domain.

I think it's incredible that all of this infrastructure is so easy to use and available for free.

*** Image attributions:

- C128 Code (code header background) is from the source code listing from my Commodore 128 program [[http://zzamboni.org/brt/2008/01/24/supercataloger-128][Supercataloguer 128]].
- [[https://www.pexels.com/photo/alphabet-board-game-bundle-close-up-278888/][Scrabble letters]] ([[file:../post][blog]] header background) from [[https://www.pexels.com/][Pexels]], licensed under [[https://www.pexels.com/photo-license/][CC0]].
- All other header background photos were taken either by my wife or me.

If you have any concerns or questions about the images used in this site, please [[file:../contact][let me know]].

** DONE Contact
CLOSED: [2018-03-25 Sun 18:34]
:PROPERTIES:
:export_hugo_section: contact
:export_hugo_custom_front_matter: :featured_image /images/phone-booth-red-trimmed.jpg
:export_hugo_weight: 05
:export_file_name: _index
:export_hugo_aliases: /contact.html
:END:

If you have any questions, comments or feedback about this site, please use the form below to send me a message.

----

@@html:{{< form-contact action="http://formspree.io/diego@zzamboni.org" >}}@@

** DONE Books
CLOSED: [2018-03-25 Sun 20:11]
:PROPERTIES:
:export_hugo_section: book
:export_hugo_custom_front_matter: :featured_image /images/book-box-thin.jpg
:export_hugo_weight: 02
:export_file_name: _index
:END:

* Book pages

The individual pages for each book.

** DONE Learning CFEngine 3
CLOSED: [2018-03-25 Sun 21:05]
:PROPERTIES:
:export_hugo_section: book
:export_file_name: cfengine
:export_hugo_custom_front_matter: :finalURL http://cf-learn.info/
:END:

{{< bookimglink style="float:right" >}}

I am the author of "Learning CFEngine 3", the best book for learning [[http://cfengine.com/][CFEngine]].

The book has its own webpage at http://cf-learn.info, please visit it for more information, code samples, etc.

You can buy the book from Amazon by clicking the link on the right.

#+hugo: more

\nbsp

* Ideas
:PROPERTIES:
:export_hugo_section: post
:END:

Ideas for things to write about.

** TODO Using and extending Seal                               :hammerspoons:
** TODO Sending things to OmniFocus                             :hammerspoon:
** TODO ox-hugo                                                  :emacs:hugo:
** TODO CryFS                                                   :cryfs:howto:
** TODO Hosting a Hugo blog in GitHub            :hugo:github:blogging:howto:
Short guide to setting up Hugo, using /docs to host to avoid branches, and setting up your custom domain.
* Posts
:PROPERTIES:
:export_hugo_section: post
:END:

Blog posts.

** Literate config files    :config:howto:literateprogramming:literateconfig:

I group here the posts about my documented config files, which include the live files from my current configuration.

*** DONE My Emacs Configuration, With Commentary                      :emacs:
CLOSED: [2017-12-17 Sun 20:14]
:PROPERTIES:
:export_file_name: 2017-12-17-my-emacs-configuration-with-commentary
:export_hugo_custom_front_matter: :featured_image /images/emacs-logo.svg :toc true
:END:
#+begin_description
I have enjoyed slowly converting my configuration files to literate programming style using org-mode in Emacs. It's now the turn of my Emacs configuration file.
#+end_description

Last update: *{{{updatetime}}}*

I have enjoyed slowly converting my configuration files to [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming]] style style using org-mode in Emacs. I previously posted my [[file:../my-elvish-configuration-with-commentary/][Elvish configuration]], and now it's the turn of my Emacs configuration file. The text below is included directly from my [[https://github.com/zzamboni/dot_emacs/blob/master/init.org][init.org]] file. Please note that the text below is a snapshot as the file stands as of the date shown above, but it is always evolving. See the [[https://github.com/zzamboni/dot_emacs/blob/master/init.org][init.org file in GitHub]] for my current, live configuration, and the generated file at [[https://github.com/zzamboni/dot_emacs/blob/master/init.el]].

#+include: "~/.emacs.d/init.org" :lines "19-"

*** DONE My Hammerspoon Configuration, With Commentary          :hammerspoon:
CLOSED: [2018-01-08 Mon 13:31]
:PROPERTIES:
:export_file_name: 2018-01-08-my-hammerspoon-configuration-with-commentary
:export_hugo_custom_front_matter: :toc true :featured_image /images/hammerspoon.png
:END:
#+begin_description
In my ongoing series of literate config files, I present to you my Hammerspoon configuration file.
#+end_description

Last update: *{{{updatetime}}}*

In my [[file:../my-elvish-configuration-with-commentary/][ongoing]] [[file:../my-emacs-configuration-with-commentary][series]] of [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate]] config files, I present to you my [[http://www.hammerspoon.org/][Hammerspoon]] configuration file. You can see the generated file at [[https://github.com/zzamboni/dot-hammerspoon/blob/master/init.lua]]. As usual, this is just a snapshot at the time shown above, you can see the current version of my configuration [[https://github.com/zzamboni/dot-hammerspoon/blob/master/init.org][in GitHub]].

#+include: "~/.hammerspoon/init.org" :lines "19-"

*** DONE My Elvish Configuration With Commentary                     :elvish:
CLOSED: [2017-11-16 Thu 20:21]
:PROPERTIES:
:export_file_name: 2017-11-16-my-elvish-configuration-with-commentary
:export_hugo_custom_front_matter: :toc true :featured_image /images/elvish-logo.svg
:END:
#+begin_description
In this blog post I will walk you through my current Elvish configuration file, with running commentary about the different sections.
#+end_description

Last update: *{{{updatetime}}}*

In this blog post I will walk you through my current [[http://elvish.io][Elvish]] configuration file, with running commentary about the different sections.

This is also my first blog post written using [[http://orgmode.org/][org-mode]], which I have started using for writing and documenting my code, using [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming]]. The content below is included unmodified from my [[https://github.com/zzamboni/dot-elvish/blob/master/rc.org][rc.org file]] (as of the date shown above), from which the [[https://github.com/zzamboni/dot-elvish/blob/master/rc.elv][rc.elv]] file is directly generated.

Without further ado...

#+include: "~/.elvish/rc.org" :lines "19-"

** Emacs                                                              :emacs:
*** DONE Beautifying Org Mode in Emacs        :orgmode:beautifulemacs:config:
CLOSED: [2018-03-21 Wed 22:45]
:PROPERTIES:
:export_hugo_bundle: 2018-03-21-using-proportional-fonts-in-emacs-with-org-mode
:export_file_name: index
:export_hugo_custom_front_matter: :toc true :featured_image /images/emacs-logo.svg
:END:
#+begin_description
Configuring Org Mode in Emacs for beautiful typography for both text and code editing.
#+end_description

Over the last few months, I have used [[https://orgmode.org/][org-mode]] more and more for writing and programming in Emacs. I love its flexibility and power, and it is the first [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming]] tool which "feels right", and I have been able to stick with it for a longer period of time than in my previous attempts.

Recently I started thinking about how I could make my editing environment more visually appealing. I am in general very happy with my Emacs' appearance. I use the [[https://github.com/Greduan/emacs-theme-gruvbox][Gruvbox theme]], and org-mode has very decent syntax highlighting. But as I write more and more prose in Emacs these days, I started thinking it might be nice to edit text in more visually-appealing fonts, including using a proportional font, which makes regular prose much more readable. I would like to share with you what I learned and my current Emacs configuration.

In the end, you can have an Emacs setup for editing org documents which looks very nice, with proportional fonts for text and monospaced fonts for code blocks, examples and other elements. To wet your appetite, here is what a fragment of my [[https://github.com/zzamboni/dot-emacs/blob/master/init.org][init.org]] file looks like:

[[file:images/emacs-init-propfonts.png][file:images/emacs-init-propfonts.png]]

**** Step 1: Configure faces for Org headlines and lists

My first step was to make  org-mode much more readable by using different fonts for headings, hiding some of the markup, and improving list bullets. I took these settings originally from Howard Abrams' excellent [[http://www.howardism.org/Technical/Emacs/orgmode-wordprocessor.html][Org as a Word Processor]] article, although I have tweaked them a bit.

First, we ask org-mode to hide the emphasis markup (e.g. =/.../= for italics, =*...*= for bold, etc.):

#+begin_src emacs-lisp :tangle no
  (setq org-hide-emphasis-markers t)
#+end_src

Then, we set up a font-lock substitution for list markers (I always use "=-=" for lists, but you can change this if you want) by replacing them with a centered-dot character:

#+begin_src emacs-lisp :tangle no
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

The =org-bullets= package replaces all headline markers with different Unicode bullets:

#+begin_src emacs-lisp :tangle no
  (use-package org-bullets
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+end_src

Finally, we set up a nice proportional font, in different sizes, for the headlines. The fonts listed will be tried in sequence, and the first one found will be used. Feel free to add your own favorite font:

#+begin_src emacs-lisp :tangle no
  (let* ((variable-tuple
          (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
                ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
                ((x-list-fonts "Verdana")         '(:font "Verdana"))
                ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
         (base-font-color     (face-foreground 'default nil 'default))
         (headline           `(:inherit default :weight bold :foreground ,base-font-color)))

    (custom-theme-set-faces
     'user
     `(org-level-8 ((t (,@headline ,@variable-tuple))))
     `(org-level-7 ((t (,@headline ,@variable-tuple))))
     `(org-level-6 ((t (,@headline ,@variable-tuple))))
     `(org-level-5 ((t (,@headline ,@variable-tuple))))
     `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
     `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
     `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
     `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
     `(org-document-title ((t (,@headline ,@variable-tuple :height 2.0 :underline nil))))))
#+end_src

**** Step 2: Setting up =variable-pitch= and =fixed-pitch= faces

My next realization was that Emacs already includes support for displaying proportional fonts with the =variable-pitch-mode= command. You can try it right now: type ~M-x~ =variable-pitch-mode= and your current buffer will be shown in a proportional font (you can disable it by running =variable-pitch-mode= again). On my Mac the default variable-pitch font is Helvetica. You can change the font used by configuring the =variable-pitch= face. You can do this interactively through the customize interface by typing ~M-x~ =customize-face= =variable-pitch=. At the moment I like [[https://en.wikipedia.org/wiki/Source_Sans_Pro][Source Sans Pro]].

As a counterpart to =variable-pitch=, you need to configure the =fixed-pitch= face for the text that needs to be shown in a monospaced font. My first instinct was to inherit this from my =default= face (I use [[https://en.wikipedia.org/wiki/Inconsolata][Inconsolata]]), but it seems that this gets remapped when =variable-pitch-mode= is active, so I had to configure it by hand with the same font as my =default= face.

What I would suggest is that you customize the fonts interactively, as you can see live how it looks on your text. You can make the configuration permanent from the customize screen as well. If you want to explicitly set them in your configuration file, you can do it with the =custom-theme-set-faces= function, like this:

#+begin_src emacs-lisp
  (custom-theme-set-faces
   'user
   '(variable-pitch ((t (:family "Source Sans Pro" :height 180 :weight light))))
   '(fixed-pitch ((t ( :family "Inconsolata" :slant normal :weight normal :height 1.0 :width normal)))))
#+end_src

*Tip:* you can get the LISP expression for your chosen font (the part that looks like =((t (:family ... )))= from the =customize-face= screen - open the "State" button and choose the "Show Lisp Expression" menu item.

You can enable =variable-pitch-mode= automatically for org buffers by setting up a hook like this:

#+begin_src emacs-lisp :tangle no
  (add-hook 'org-mode-hook 'variable-pitch-mode)
#+end_src

**** Step 2: Use long lines and =visual-line-mode=

One thing you will notice right away with proportional fonts is that filling paragraphs no longer makes sense. This is because =fill-paragraph= works based on the number of characters in a line, but with a proportional font, characters have different widths, so a filled paragraph looks strange:

[[file:images/emacs-filled-paragraph.png][file:images/emacs-filled-paragraph.png]]

Of course, you can still do it, but there's a better way. With =visual-line-mode= enabled, long lines will flow and adjust to the width of the window. This is great for writing prose, because you can choose how wide your lines are by just resizing your window.

[[file:images/emacs-narrow-window.png][file:images/emacs-narrow-window.png]]

[[file:images/emacs-wide-window.png][file:images/emacs-wide-window.png]]

There is one habit you have to change for this to work: the instinct (at least for me) of pressing ~M-q~ every once in a while to readjust the current paragraph. I personally think it's worth it.

You can enable =visual-line-mode= automatically for org buffers by setting up another hook:

#+begin_src emacs-lisp :tangle no
  (add-hook 'org-mode-hook 'visual-line-mode)
#+end_src

**** Step 4: Configure faces for specific Org elements

After all the changes above, you will have nice, proportional fonts in your Org buffers. However, there are some things for which you still want monospace fonts! Things like source blocks, examples, tags and some other markup elements still look better in a fixed-spacing font, in my opinion. Fortunately, org-mode has an extremely granular face selection, so you can easily customize them to have different elements shown in the correct font, color, and size.

*Tip:* you can use ~C-u~ ~C-x~ ~=~ (which runs the command =what-cursor-position= with a prefix argument) to show information about the character under the cursor, including the face which is being used for it. If you find a markup element which is not correctly configured, you can use this to know which face you have to customize.

You can configure specific faces any way you want, but if you simply want them to be rendered in monospace font, you can set them to inherit from the =fixed-pitch= face we configured before. You can also inherit from multiple faces to combine their attributes.

Here are the faces I have configured so far (there are probably many more to do, but I don't use org-mode to its full capacity yet). I'm showing here the LISP expressions, but you can just as well configure them using =customize-face=.

#+begin_src emacs-lisp
  (custom-theme-set-faces
   'user
   '(org-block                 ((t (:inherit fixed-pitch))))
   '(org-document-info         ((t (:foreground "dark orange"))))
   '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
   '(org-link                  ((t (:foreground "royal blue" :underline t))))
   '(org-meta-line             ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-property-value        ((t (:inherit fixed-pitch))) t)
   '(org-special-keyword       ((t (:inherit (font-lock-comment-face fixed-pitch)))))
   '(org-tag                   ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
   '(org-verbatim              ((t (:inherit (shadow fixed-pitch))))))
#+end_src

One minor issue I have noticed is that, in =variable-pitch-mode=, the fixed-pitch blocks have a slight increase in inter-line spacing. This is not a deal breaker for me, but it is a noticeable difference. This can be observed in the following screenshot, which shows the block of code above embedded in the org-mode buffer and in the block-editing buffer, which uses the fixed-width font. If you know a way in which this could be fixed, please let me know!

[[file:images/emacs-differing-heights.png][file:images/emacs-differing-heights.png]]

**** Conclusion

The setup described above has considerably improved my enjoyment of writing in Emacs. I hope you find it useful. If you have any feedback, suggestions or questions, please let me know in the comments.

** Hammerspoon                                                  :hammerspoon:
:PROPERTIES:
:export_hugo_custom_front_matter: :toc true :featured_image /images/hammerspoon.png
:END:

*** DONE Getting Started With Hammerspoon                       :howto:mac:
CLOSED: [2017-08-21 16:34]
:PROPERTIES:
:export_hugo_bundle: 2017-08-21-getting-started-with-hammerspoon
:export_file_name: index
:END:
#+begin_description
This is the first installment of a series of posts about Hammerspoon, a staggeringly powerful automation utility which gives you an amazing degree of control over your Mac, allowing you to automate and control almost anything. In the word of Hammerspoon's motto: /Making the runtime, funtime/.
#+end_description

This is the first installment of a series of posts about Hammerspoon, a staggeringly powerful automation utility which gives you an amazing degree of control over your Mac, allowing you to automate and control almost anything. In the word of Hammerspoon's motto: /Making the runtime, funtime/.

**** Why Hammerspoon?

[[http://www.hammerspoon.org/][Hammerspoon]] is a Mac application that allows you to achieve an unprecedented level of control over your Mac.  Hammerspoon enables interaction with the system at multiple layers--from low-level file system or network access, mouse or keyboard event capture and generation, all the way to manipulating applications or windows, processing URLs and drawing on the screen. It also allows interfacing with [[https://www.macosxautomation.com/applescript/][AppleScript]], Unix commands and scripts, and other applications. Hammerspoon configuration is written in [[https://www.lua.org/about.html][Lua]], a popular embedded programming language.

Using Hammerspoon, you can replace many stand-alone Mac utilities for controlling or customizing specific aspects of your Mac (the kind that tends to overcrowd the menubar). For example, the following are doable using Hammerspoon (these are all things I do with it on my machine - each paragraph links to the corresponding sections in my [[/post/my-hammerspoon-configuration-with-commentary/][config file]]):

- Add missing or more convenient keyboard shortcuts to applications, even for complex multi-step actions. For example: [[/post/my-hammerspoon-configuration-with-commentary/#organization-and-productivity][automated tagging and filing in Evernote, mail/note archival in Mail, Outlook and Evernote, filing items from multiple applications to OmniFocus using consistent keyboard shortcuts]], or [[/post/my-hammerspoon-configuration-with-commentary/#other-applications][muting/unmuting a conversation in Skype]].
- [[/post/my-hammerspoon-configuration-with-commentary/#url-dispatching-to-site-specific-browsers][Open URLs in different browsers based on regular expression patterns]].  When combined with Site-specific Browsers (I use [[https://github.com/dmarmor/epichrome][Epichrome]]), this allows for highly flexible management of bookmarks, plugins and search configurations.
- Replace Spotlight, Lacona and other launchers with a [[/post/my-hammerspoon-configuration-with-commentary/#seal][fully configurable, extensible launcher]], which allows not only to open applications, files and bookmarks, but to trigger arbitrary Lua functions.
- [[/post/my-hammerspoon-configuration-with-commentary/#window-and-screen-manipulation][Manipulate windows]] using keyboard shortcuts to resize, move and arrange them.
- [[/post/my-hammerspoon-configuration-with-commentary/#network-transitions][Set up actions to happen automatically when switching between WiFi networks]]--for example for reconfiguring proxies in some applications.
- [[/post/my-hammerspoon-configuration-with-commentary/#pop-up-translation][Keyboard-triggered translation]] of selected text between arbitrary human languages.
- Keep a configurable and persistent [[/post/my-hammerspoon-configuration-with-commentary/#organization-and-productivity][clipboard history]].
- [[/post/my-hammerspoon-configuration-with-commentary/#other-applications][Automatically pause audio playback]] when headphones are unplugged.

Hammerspoon is the most powerful Mac automation utility I have ever used. If you are a programmer, it can make using your Mac vastly more fun and productive.

**** How does Hammerspoon work?

Hammerspoon acts as a thin layer between the operating system and a Lua-based configuration language. It includes extensions for querying and controlling many aspects of the system. Some of the lower-level extensions are written in Objective-C, but all of them expose a Lua API, and it is trivial to write your own extensions or modules to extend its functionality.

From the Hammerspoon configuration you can also execute external commands, run AppleScript or JavaScript code using the OSA scripting framework, establish network connections and even run network servers; you can capture and generate keyboard events, detect network changes, USB or audio devices being plugged in or out, changes in screen or keyboard language configuration; you can draw directly on the screen to display whatever you want; and many other things. Take a quick look at the [[http://www.hammerspoon.org/docs/index.html][Hammerspoon API index page]] to get a feeling of its extensive capabilities. And that is only the libraries that are built into Hammerspoon. There is an extensive and growing collection of [[http://www.hammerspoon.org/Spoons/][Spoons]], modules written in pure Lua that provide additional functionality and integration. And of course, the configuration is simply Lua code, so you can write your own code to do whatever you want.

Interested? Let's get started!

**** Installing Hammerspoon

Hammerspoon is a regular Mac application. To install it by hand, you just need to download it from [[https://github.com/Hammerspoon/hammerspoon/releases/latest]], unzip the downloaded file and drag it to your /Applications folder (or anywhere else you want).

If you are automation-minded like me, you probably use [[https://brew.sh/][Homebrew]] and its plugin [[https://caskroom.github.io/][Cask]] to manage your applications. In this case, you can use Cask to install Hammerspoon:

#+begin_src shell
  brew cask install hammerspoon
#+end_src

When you run Hammerspoon for the first time, you will see its icon appear in the menubar, and a notification telling you that it couldn't find a configuration file. Let's fix that!

[[file:images/hammerspoon-startup.png]]

{{% tip %}}
 If you click on the initial notification, your web browser will open to the excellent [[http://www.hammerspoon.org/go/][Getting Started with Hammerspoon]] page, which I highly recommend you read for more examples.
{{% /tip %}}

**** Your first Hammerspoon configuration

Let us start with a few simple examples. As tradition mandates, we will start with a "Hello World" example. Open =$HOME/.hammerspoon/init.lua= (Hammerspoon will create the directory upon first startup, but you need to create the file) in your favorite editor, and type the following:

#+begin_src lua
  hs.hotkey.bindSpec({ { "ctrl", "cmd", "alt" }, "h" },
    function()
      hs.notify.show("Hello World!", "Welcome to Hammerspoon", "")
    end
  )
#+end_src

Save the file, and from the Hammerspoon icon in the menubar, select "Reload config". Apparently nothing will happen, but if you then press {{{keys(Ctrl ⌘ Alt h)}}} on your keyboard, you will see a notification on your screen welcoming you to the world of Hammerspoon.

[[file:images/hammerspoon-hello-world.png]]

Although it should be fairly self-explanatory, let us dissect this example to give you a clearer understanding of its components:

- All Hammerspoon built-in extensions start with =hs.= In this case, {{{hsapi(hs.hotkey)}}} is the extension that handles keyboard bindings. It allows us to easily define which functions will be called in response to different keyboard combinations. You can even differentiate between the keys being pressed, released or held down if you need to. The other extension used in this example is {{{hsapi(hs.notify)}}}, which allows us to interact with the macOS Notification Center to display, react and interact with notifications.

- Within =hs.hotkey=, the {{{hsapi(hs.hotkey,bindSpec)}}} function allows you to bind a function to a pressed key. Its first argument is a key specification which consists of a list (Lua lists and table literals are represented using curly braces) with two elements: a list of the key modifiers, and the key itself. In this example, ={ { "ctrl", "cmd", "alt" }, "h" }= represents pressing {{{keys(Ctrl ⌘ Alt h)}}}.

- The second argument to =bindSpec= is the function to call when the key is pressed. Here we are defining an inline anonymous function using =function() ... end=.

- The callback function uses {{{hsapi(hs.notify,show)}}} to display the message. Take a quick look at the {{{hsapi(hs.notify)}}} documentation to get an idea of its extensive capabilities, including configuration of all aspects of a notification's appearance and buttons, and the functions to call upon different user actions.

Try changing the configuration to display a different message or use a different key. After every change, you need to instruct Hammerspoon to reload its configuration, which you can do through its menubar item.

**** Debugging tools and the Hammerspoon console

As you start modifying your configuration, errors will happen, as they always do when coding. To help in development and debugging, Hammerspoon offers a console window where you can see any errors and messages printed by your Lua code as it executes, and also type code to be evaluated. It is a very useful tool while developing your Hammerspoon configuration.

To invoke the console, you normally choose "Console..." from the Hammerspoon menubar item. However, this is such a common operation, that you might find it useful to also set a key combination for showing the console. Most of Hammerspoon's internal functionality is also accessible through its API. In this case, looking at the {{{hsapi(hs,,documentation for the main =hs= module)}}} reveals that there is an {{{hsapi(hs,toggleConsole)}}} function. Using the knowledge you have acquired so far, you can easily configure a hotkey for opening and hiding the console:

#+begin_src lua
  hs.hotkey.bindSpec({ { "ctrl", "cmd", "alt" }, "y" }, hs.toggleConsole)
#+end_src

Once you reload your configuration, you should be able to use {{{keys(Ctrl ⌘ Alt y)}}} to open and close the console. Any Lua code you type in the Console will be evaluated in the main Hammerspoon context, so you can add to your configuration directly from there. This is a good way to incrementally develop your code before committing it to the =init.lua= file.

You may have noticed by now another common operation while developing Hammerspoon code: reloading the configuration, which you normally have to do from the Hammerspoon menu. So why not set up a hotkey to do that as well? Again, the {{{hsapi(hs)}}} module comes to our help with the {{{hsapi(hs,reload)}}} method:

#+begin_src lua
  hs.hotkey.bindSpec({ { "ctrl", "cmd", "alt" }, "r" }, hs.reload)
#+end_src

Another useful development tool is the =hs= command, which you can run from your terminal to get a Hammerspoon console. To install it, you can use the {{{hsapi(hs.ipc",cliInstall)}}} function, which you can just add to your =init.lua= file to check and install the command every time Hammerspoon runs.

{{% warning %}}
 {{{hsapi(hs.ipc,cliInstall)}}} creates symlinks under =/usr/local/= to the =hs= command and its manual page file, located inside the Hammerspoon application bundle. Under some circumstances (particularly if you build Hammerspoon from source, or if you install different versions of it), you may end up with broken symlinks. If the =hs= command stops working and =hs.ipc.cliInstall()= doesn't fix it, look for broken symlinks left behind from old versions of Hammerspoon.  Remove them and things should work again.
{{% /warning %}}

Now you have all the tools for developing your Hammerspoon configuration. In the next installment we will look at how you can save yourself a lot of coding by using pre-made modules. In the meantime, feel free to look through my [[/post/my-hammerspoon-configuration-with-commentary/][Hammerspoon configuration file]] for ideas, and please let me know your thoughts in the comments!

*** DONE Using Spoons in Hammerspoon                               :spoons:
CLOSED: [2017-09-01 17:55]
:PROPERTIES:
:export_hugo_bundle: 2017-09-01-using-spoons-in-hammerspoon
:export_file_name: index
:END:
#+begin_description
In this second article about Hammerspoon, we look into /Spoons/, modules written in Lua which can be easily installed and loaded into Hammerspoon to provide ready-to-use functionality. Spoons provide a predefined API to configure and use them. They are also a good way to share your own work with other users.
#+end_description

In this second article about Hammerspoon, we look into /Spoons/, modules written in Lua which can be easily installed and loaded into Hammerspoon to provide ready-to-use functionality. Spoons provide a predefined API to configure and use them. They are also a good way to share your own work with other users.

See also the [first article in this series]({{< ref "/post/2017-08-21-getting-started-with-hammerspoon" >}}).

**** Using a Spoon to locate your mouse
  :PROPERTIES:
  :CUSTOM_ID: using-a-spoon-to-locate-your-mouse
  :END:

As a first example, we will use the [[http://www.hammerspoon.org/Spoons/MouseCircle.html][MouseCircle]] spoon, which allows us to set up a hotkey that displays a color circle around the current location of the mouse pointer for a few seconds, to help you locate it.

To install the spoon, download its zip file from [[https://github.com/Hammerspoon/Spoons/raw/master/Spoons/MouseCircle.spoon.zip]], unpack it, and double-click on the resulting =MouseCircle.spoon= file.  Hammerspoon will install the Spoon under =~/.hammerspoon/Spoons/=.

[[file:images/mousecircle.png]]

Once a Spoon is installed, you need to use the =hs.loadSpoon()= function to load it. Type the following in the Hammerspoon console, or add it to your =init.lua= file and reload the configuration:

#+begin_src lua
  hs.loadSpoon("MouseCircle")
#+end_src

After a spoon is loaded, and depending on what it does, you may need to configure it, assign hotkeys, and start it. A spoon's API is available through the =spoon.<SpoonName>= namespace. To learn the API you need to look at the spoon documentation page. In the case of MouseCircle, a look at [[http://www.hammerspoon.org/Spoons/MouseCircle.html]] reveals that it has two methods (=bindHotkeys()= and =show()=) and one configuration variable (=color=) available under =spoon.MouseCircle=.

The first API call is =spoon.MouseCircle:bindHotkeys()=, which allows us to set up a hotkey that shows the mouse locator circle around the location of the mouse pointer. Let's say we wanted to bind the mouse circle to {{{keys(Ctrl ⌘ Alt d)}}}. According to the MouseCircle documentation, the name for this action is =show=, so we can do the following:

#+begin_src lua
  spoon.MouseCircle:bindHotkeys({
    show = { { "ctrl", "cmd", "alt" }, "d" }
  })
#+end_src

Once you do this, press the hotkey and you should see a red circle appear around the mouse cursor, and fade away after 3 seconds.

{{% tip %}}
All spoons which offer the possibility of binding hotkeys have to expose it through the same API:

#+begin_src lua
  spoon.SpoonName:bindHotkeys({ action1 = keySpec1,
                                action2 = keySpec2, ... })
#+end_src

Each =actionX= is a name defined by the spoon, which refers to something that can be bound to a hotkey, and each =keySpecX= is a table with two elements: a list of modifiers and the key itself, such as ={ { "ctrl", "cmd", "alt" }, "d" }=.
{{% /tip %}}

The second API call in the MouseCircle spoon is =show()=, which triggers the functionality of showing the locator circle directly. Let's try it -- type the following in the console:

#+begin_src lua
  spoon.MouseCircle:show()
#+end_src

Most spoons are structured like this: you can set up hotkeys to trigger the main functionality, but you can also trigger it via method calls.  Normally you won't use these methods, but their availability makes it possible for you to use spoon functionality from our own configuration, or from other spoons, to create further automation.

=spoon.MouseCircle.color= is a public configuration variable exposed by the spoon, which specifies the color that will be used to draw the circle. Colors are defined according to the documentation for the {{{hsapi(hs.drawing.color)}}} module. Several color collections are supported, including the OS X system collections and a few defined by Hammerspoon itself. Color definitions are stored in Lua tables indexed by their name. For example, you can view the {{{hsapi(hs.drawing.color,hammerspoon)}}} table, including the color definitions, by using the convenient {{{hsapi(hs.inspect)}}} method on the console:

#+begin_src lua
  > hs.inspect(hs.drawing.color.hammerspoon)
  {
    black = {
      alpha = 1,
      blue = 0.0,
      green = 0.0,
      red = 0.0
    },
    green = {
      alpha = 1,
      blue = 0.0,
      green = 1.0,
      red = 0.0
    },
    osx_red = {
      alpha = 1,
      blue = 0.302,
      green = 0.329,
      red = 0.996
    },
    osx_green = {
  ...
#+end_src

{{% tip %}}

Lua does not include a function to easily get the keys of a table so you have to use the {{{luafun(pairs)}}} function to loop over the key/value pairs of the table. The {{{hsapi(hs.inspect)}}} function is convenient, but to get just the list of tables and the color names, without the color definitions themselves, you can use the following code (if you type this in the console you have to type it all in a single line -- and beware, the output is a long list):

#+begin_src lua
  for listname,colors in pairs(hs.drawing.color.lists()) do
    print(listname)
    for color,def in pairs(colors) do
      print("  " .. color)
    end
  end
#+end_src

{{% /tip %}}

If we wanted to make the circle green, we can assign the configuration value like this:

#+begin_src lua
  spoon.MouseCircle.color = hs.drawing.color.hammerspoon.green
#+end_src

The next time you invoke the =show()= method, either directly or through the hotkey, you will see the circle in the new color.

{{% tip %}}

(We will look at this in more detail in a future installment about Lua, but in case you were wondering...)

You may have noticed that the configuration variable was accessed with a dot (=spoon.MouseCircle.color=), and we also used it for some function calls earlier (e.g. {{{hsapi(hs.notify,show)}}}, whereas for the =show()= method we used a colon (=spoon.MouseCircle:show()=). The latter is Lua's object-method-call notation, and its effect is to pass the object on which the method is being called as an implicit first argument called =self=. This is simply a syntactic shortcut, i.e. the following two are equivalent:

#+begin_src lua
  spoon.MouseCircle:show()
  spoon.MouseCircle.show(spoon.MouseCircle)
#+end_src

Note that in the second statement, we are calling the method using the dot notation, and explicitly passing the object as the first argument.  Normally you would use colon notation, but the alternative can be useful when constructing function pointers. For example, if you wanted to manually bind a second key to show the mouse circle, you might initially try to use the following:

#+begin_src lua
  hs.hotkey.bindSpec({ {"ctrl", "alt", "cmd" }, "p" },
                     spoon.MouseCircle:show)
#+end_src

But this results in an error. The correct way is to wrap the call in an anonymous function:

#+begin_src lua
  hs.hotkey.bindSpec({ {"ctrl", "alt", "cmd" }, "p" },
                     function() spoon.MouseCircle:show() end)
#+end_src

Alternatively, you can use the {{{hsapi(hs.fnutils,partial)}}} function to construct a function pointer that includes the correct first argument:

#+begin_src lua
  hs.hotkey.bindSpec({ {"ctrl", "alt", "cmd" }, "p" },
                     hs.fnutils.partial(spoon.MouseCircle.show,
                                        spoon.MouseCircle))
#+end_src

This is more verbose than the previous example, but the technique can be useful sometimes. Although Lua is not a full functional language, it supports using functions as first-class values, and the {{{hsapi(hs.fnutils)}}} extension includes a number of functions that make it easy to use them.

{{% /tip %}}

By now you know enough to use spoons with Hammerspoon's native capabilities: [[http://www.hammerspoon.org/Spoons/][look for the ones you want]], download and install them by hand, and configure them in your =init.lua= using their configuration variables and API. In the next sections you will learn more about the minimum API of spoons, and how to install and configure spoons in a more automated way.

**** The Spoon API
  :PROPERTIES:
  :CUSTOM_ID: the-spoon-api
  :END:

The advantage of using spoons is that you can count on them to adhere to a [[https://github.com/Hammerspoon/hammerspoon/blob/master/SPOONS.md#api-conventions][defined API]], which makes it easier to automate their use. Although each spoon is free to define additional variable and methods, the following are standard:

- =SPOON:init()= is called automatically (if it exists) by {{{hsapi(hs,loadSpoon)}}} after loading the spoon, and can be used to initialize variables or anything else needed by the Spoon.

- =SPOON:start()= should exist if the spoon requires any ongoing or background processes such as timers or watchers of any kind.

- =SPOON:stop()= should exist if =start()= does, to stop any background processes that were started by =start()=.

- =SPOON:bindHotkeys(map)= is exposed by spoons which allow binding hotkeys to certain actions. Its =map= argument is a Lua table with key/value entries of the following form: =ACTION = { MODS, KEY }=, where ACTION is a string defined by the spoon (multiple such actions can be defined), MODS is a list of key modifiers (valid values are ="cmd"=, ="alt"=, ="ctrl"= and ="shift"=), and KEY is the key to be bound, as shown in our previous example. All available actions for a spoon should be listed in its documentation.

**** Automated Spoon installation and configuration
  :PROPERTIES:
  :CUSTOM_ID: automated-spoon-installation-and-configuration
  :END:

Once you develop a complex Hammerspoon configuration using spoons, you may start wondering if there is an easy way to manage them. There are no built-in mechanisms for automatically installing spoons, but you can use a spoon called [[http://www.hammerspoon.org/Spoons/SpoonInstall.html][SpoonInstall]] that implements this functionality. You can download it from [[http://www.hammerspoon.org/Spoons/SpoonInstall.html]]. Once installed, you can use it to declaratively install, configure and run spoons. For example, with SpoonInstall you can use the MouseCircle spoon as follows:

#+begin_src lua
  hs.loadSpoon("SpoonInstall")
  spoon.SpoonInstall:andUse("MouseCircle", {
                    config = {
                       color = hs.drawing.color.osx_red,
                    },
                    hotkeys = {
                       show = { { "ctrl", "cmd", "alt"}, "d" }
                    }})
#+end_src

If the MouseCircle spoon is not yet installed, =spoon.SpoonInstall:andUse()= will automatically download and install it, and set its configuration variables and hotkeys according to the declaration.

If there is nothing to configure in the spoon, =spoon.SpoonInstall:andUse("SomeSpoon")= does exactly the same as =hs.loadSpoon("SomeSpoon")=. But if you want to set configuration variables, hotkey bindings or other parameters, the following keys are recognized in the map provided as a second parameter:

- =config= is a Lua table containing keys corresponding to configuration variables in the spoon. In the example above, =config = { color = hs.drawing.color.osx_red }= has the same effect as setting =spoon.MouseCircle.color = hs.drawing.color.osx_red=

- =hotkeys= is a Lua table with the same structure as the mapping parameter passed to the =bindHotkeys= method of the spoon. In our example above, =hotkeys = { show = { { "ctrl", "cmd", "alt"}, "d" } }= automatically triggers a call to =spoon.MouseCircle:bindHotkeys({ show = { { "ctrl", "cmd", "alt"}, "d" } })=.

- =loglevel= sets the log level of the =logger= attribute within the spoon, if it exists. The valid values for this attribute are 'nothing', 'error', 'warning', 'info', 'debug', or 'verbose'.

- =start= is a boolean value which indicates whether to call the Spoon's =start()= method (if it has one) after configuring everything else.

- =fn= specifies a function which will be called with the freshly-loaded Spoon object as its first argument. This can be used to execute other startup or configuration actions that are not covered by the other attributes. For example, if you use the {{{spoon(Seal)}}} spoon (a configurable launcher), you need to call its =loadPlugins()= method to specify which Seal plugins to use. You can achieve this with something like this:

  #+begin_src lua
    spoon.SpoonInstall:andUse("Seal",
      { hotkeys = { show = { {"cmd"}, "space" } },
        fn = function(s)
                 s:loadPlugins({"apps", "calc", "safari_bookmarks"})
             end,
             start = true,
      })
  #+end_src

- =repo= indicates the repository from where the Spoon should be installed if needed. Defaults to ="default"=, which indicates the official Spoon repository at [[http://www.hammerspoon.org/Spoons/]]. I keep a repository of unofficial Spoons at [[http://zzamboni.org/zzSpoons/]], and others may be available by the time you read this.

- =disable= can be set to =true= to disable the Spoon (easier than commenting it out when you want to temporarily disable a spoon) in your configuration.

{{% tip %}}

You can assign functions and modules to variables to improve readability of your code. For example, in my =init.lua= file I make the following assignment:

#+begin_src lua
  Install=spoon.SpoonInstall
#+end_src

Which allows me to write =Install:andUse("MouseCircle", …​ )=, which is shorter and easier to read.

{{% /tip %}}

***** Managing repositories and spoons using SpoonInstall
   :PROPERTIES:
   :CUSTOM_ID: managing-repositories-and-spoons-using-spooninstall
   :END:

Apart from the =andUse()= "all-in-one" method, SpoonInstall has methods for specific repository- and spoon-maintenance operations. As of this writing, there are two Spoon repositories: the official one at [[http://www.hammerspoon.org/Spoons/]], and my own at [[http://zzamboni.org/zzSpoons/]], where I host some unofficial and in-progress Spoons.

The configuration variable used to specify repositories is =SpoonInstall.repos=. Its default value is the following, which configures the official repository identified as "default":

#+begin_src lua
  {
    default = {
        url = "https://github.com/Hammerspoon/Spoons",
        desc = "Main Hammerspoon Spoon repository",
    }
  }
#+end_src

To configure a new repository, you can define an extra entry in this variable. The following code creates an entry named "zzspoons" for my Spoon repository:

#+begin_src lua
  spoon.SpoonInstall.repos.zzspoons = {
     url = "https://github.com/zzamboni/zzSpoons",
     desc = "zzamboni's spoon repository",
  }
#+end_src

After this, both "zzspoons" and "default" can be used as values to the =repo= attribute in the =andUse()= method, and in any of the other methods that take a repository identifier as a parameter. You can find the full API documentation at [[http://www.hammerspoon.org/Spoons/SpoonInstall.html]].

**** Conclusion
  :PROPERTIES:
  :CUSTOM_ID: conclusion
  :END:

Spoons are a great mechanism for structuring your Hammerspoon configuration. If you want an example of a working configuration based almost exclusively on Spoons, you can view my own Hammerspoon configuration at https://github.com/zzamboni/dot-hammerspoon.

** Elvish                                                           :elvish:
:PROPERTIES:
:export_hugo_custom_front_matter: :featured_image /images/elvish-logo.svg
:END:

*** DONE Bang-Bang (!!, !$) Shell Shortcuts in Elvish   :shell:unix:config:
CLOSED: [2017-12-04 Mon 22:15]
:PROPERTIES:
:export_file_name: 2017-12-04-bang-bang-shortcuts-in-elvish
:END:
#+begin_description
How to set up the bash !! and !$ shortcuts for accessing the previous command in Elvish.
#+end_description

(Updated on March 19th, 2018 to use the new [[https://elvish.io/ref/epm.html][Elvish Package Manager]])

The bash shortcuts (maybe older? I'm not sure in which shell these originated) for "last command" (=!!=) and "last argument of last command" (=!$=) are, for me at least, among the most strongly imprinted in my muscle memory, and I use them all the time. Although these shortcuts are not available in [[file:/post/elvish-an-awesome-unix-shell/][Elvish]] by default, they are easy to implement. I have written a module called [[https://github.com/zzamboni/elvish-modules/blob/master/bang-bang.org][bang-bang]] which you can readily use as follows:

- Use [[https://elvish.io/ref/epm.html][epm]] to install my elvish-modules package (you can also add this to your =rc.elv= file to have the package installed automatically if needed):

  #+begin_src elvish
    use epm
    epm:install github.com/zzamboni/elvish-modules
  #+end_src

- In your =rc.elv= (see [[file:/post/my-elvish-configuration-with-commentary/][mine]] as an example), add the following to load the =bang-bang= module and to set up the appropriate keybindings:

  #+begin_src elvish
    use github.com/zzamboni/elvish-modules/bang-bang
  #+end_src

That's it! Start a new shell window, and test how command-history mode can be invoked by the =!= key. Assuming your last command was =ls -l ~/.elvish/rc.elv=, when you press =!= you will see the following:

#+begin_example
  bang-lastcmd [A C] _
  ! ls -l .elvish/rc.elv
  0 ls
  1 -l
  2/$ .elvish/rc.elv
  Alt-! !
#+end_example

If you press =!= again, the whole last command will be inserted. If you press =$= (or =2=), only the last argument will be inserted. You can insert any other component of the previous command using its corresponding number. If you want to insert an exclamation sign, you can press =Alt-!=.

Note that by default, =Alt-!= will also be bound to trigger this mode, so you can fully replace the default [[https://elvish.io/learn/cookbook.html]["last command" mode]] in Elvish.

Have fun with Elvish!
*** DONE Using and writing completions in Elvish :shell:completions:unix:config:
CLOSED: [2018-06-13 Wed 20:25]
:PROPERTIES:
:export_file_name: 2018-06-13-using-and-writing-completions-in-elvish
:export_hugo_custom_front_matter: :toc true :featured_image /images/elvish-logo.svg
:END:
#+begin_description
Like other Unix shells, Elvish has advanced command-argument completion capabilities. In this article I will explore the existing completions, and show you how you can create your own (and contribute them back to the community!)
#+end_description

Like other Unix shells, [[https://elvish.io/][Elvish]] has advanced command-argument completion capabilities. In this article I will explore the existing completions, and show you how you can create your own (and contribute them back to the community).

**** Using existing completions

There is a growing body of shell completions that you can simply load and use.

Elvish has a still-small but growing collection of completions that have been created by its users. These are a few that I know of (let me know if you know others!):

- My own [[https://github.com/zzamboni/elvish-completions][zzamboni/elvish-completions]] package, which contains completions for [[https://github.com/zzamboni/elvish-completions/blob/master/git.org][git]] (providing automatically-generated completions for all commands and their options, plus hand-crafted argument completions for many of them), [[https://github.com/zzamboni/elvish-completions/blob/master/ssh.org][ssh]], [[https://github.com/zzamboni/elvish-completions/blob/master/vcsh.org][vcsh]], [[https://github.com/zzamboni/elvish-completions/blob/master/cd.org][cd]], and a few of Elvish's [[https://github.com/zzamboni/elvish-completions/blob/master/builtins.org][built-in functions and modules]]. It also contains [[https://github.com/zzamboni/elvish-completions/blob/master/comp.org][comp]], a framework for building completers, which we will explore in more detail below. To use any of these modules, you just need to install the elvish-completions package, and then load the modules you want. For example:
  #+begin_src elvish
    epm:install &silent-if-installed github.com/zzamboni/elvish-completions
    use github.com/zzamboni/elvish-completions/vcsh
    use github.com/zzamboni/elvish-completions/cd
    use github.com/zzamboni/elvish-completions/ssh
    use github.com/zzamboni/elvish-completions/builtins
    use github.com/zzamboni/elvish-completions/git
  #+end_src
- xiaq's [[https://github.com/xiaq/edit.elv/blob/master/compl/go.elv][edit.elv/compl/go.elv]], which provides extensive hand-crafted completions for =go=. You can also install this one as an Elvish package:
  #+begin_src elvish
    epm:install &silent-if-installed github.com/xiaq/edit.elv
    use github.com/xiaq/edit.elv/compl/go
    go:apply
  #+end_src
- occivink's [[https://github.com/occivink/config/blob/master/.elvish/lib/completers.elv][completers.elv]] file, which contains completers for =kak=, =ssh=, =systemctl=, =ffmpeg= and a few other commands.
- Tw's [[https://github.com/tw4452852/MyConfig/tree/master/config/.elvish/lib/completer][completer/]] files, which contains completions for =adb=, =git= and =ssh=.
- SolitudeSF's [[https://github.com/SolitudeSF/dot/blob/master/elvish/lib/completers.elv][completers.elv]] file, which contains completers for =cd=, =kak=, =kitty=, =git=, =man=, =pkill= and quite a few other commands.

As of this writing, there is no "official" collection of Elvish completions, so feel free to look at the existing ones and choose/use the ones that work best for you.

Since the collection is not yet very big, it's likely you will want to build your own completions. This is what the next section is about.

**** Creating your own completions

Elvish has a simple but powerful argument-completion mechanism. You can find the full documentation [[https://elvish.io/ref/edit.html#completion-api][in the Elvish reference]], but let's take a quick look here.

***** Basic (built-in) argument completion mechanisms

Command argument completion in Elvish is implemented by functions stored inside =$edit:completion:arg-completer=. This variable is a map in which the indices are command names, and the values are functions which must receive a variable number of arguments. When the user types =cat= ~Space~ ~Tab~, the function stored in =$edit:completion:arg-completer[cat]= (if any) is called, as follows:

#+begin_src elvish
  $edit:completion:arg-completer[cat] cat ''
#+end_src

The function receives the full current command line as arguments, including the current argument, which might be empty as in the example above, or be a partially typed string. For example, if the user types =cat f= ~Tab~, the completer function will be called like this:

#+begin_src elvish
  $edit:completion:arg-completer[cat] cat 'f'
#+end_src

The completion function must use its arguments to determine the appropriate completions at that point, and return them by one of the following methods (which can be combined):

- Output the completions to stdout, one per line;
- Output the completions to the data stream (using =put=);
- Output the completions using the =edit:complex-candidate= command, which can additionally specify a suffix to append to the completion in the completion menu or in the returned value, and a style to use (as accepted by =edit:styled=). The full syntax of =edit:complex-candidate= is as follows:
  #+begin_src elvish
    edit:complex-candidate &code-suffix='' &display-suffix='' &style='' $string
  #+end_src
  =$string= is the option to display; =&code-suffix= indicates a suffix to be appended to the completion string when the user selects it; =&display-suffix= indicates a suffix to be shown in the completion menu (but which is not returned as part of the completion); and =&style= indicates a text style to use in the completion menu.

Keep in mind that the options returned by the completion function are additionally filtered by what the user has typed so far. This means that the last argument can usually be ignored, since Elvish will automatically do the filtering. An exception to this is if you want to return different /types of things/ depending on what the user has typed already. For example, if the last argument start with =-=, you may want to return the possible command-line options, and return regular argument completions otherwise.

*Example #1:* A very simple completer for the =brew= command:

#+begin_src elvish
  edit:completion:arg-completer[brew] = [@cmd]{
    len = (count $cmd)
    if (eq $len 2) {
      if (has-prefix $cmd[-1] -) {
        put '--version' '--verbose'
      } else {
        put install uninstall
      }
    } elif (eq $len 3) {
      brew search | eawk [l @f]{ put $@f }
    }
  }
#+end_src

If the function receives two arguments, we check to see if the last argument begins with a dash. If so, we return the possible command-line options, otherwise we return the two commands =install= and =uninstall=. If we receive three arguments (i.e. we are past the initial command), we return the list of possible packages to install or uninstall.

You may noticed that there are many cases that this simple function does not handle correctly. For example, if you type =brew --verbose= ~Space~ ~Tab~, you get the list of packages as completion, which does not make sense at that point. We will look at more complex and complete completion functions next.

The first step to more complex completions is the =edit:complete-getopt= command, which allows us to specify a sequence of positional completion functions. The general syntax of the command is:

#+begin_src elvish
  edit:complete-getopt $args $opts $handlers
#+end_src

Please see [[https://elvish.io/ref/edit.html#editcomplete-getopt][its documentation]] for a full description of the arguments.

*Example #2:* The completer for =brew= shown before can be specified like this:

#+begin_src elvish
  edit:completion:arg-completer[brew] = [@cmd]{
    edit:complete-getopt $cmd[1:] \
    [[&long=version] [&long=verbose]] \
    [
      [_]{ put install uninstall }
      [_]{ brew search | eawk [_ @f]{ put $@f } }
      ...
    ]
  }
#+end_src

This new completer overcomes a few of the limitations in our previous attempt. For one, the =install= and =uninstall= commands are now properly completed even if you specify options before. Furthermore, the =...= at the end of the handler list indicates that the previous one (the package names) will be repeated for all further arguments - this makes it possible to complete multiple package names to install or uninstall. However, it still has some limitations! For example, it will give you all existing packages as possible arguments to =uninstall=, which only accepts already installed packages.

In addition to =complete-getopt=, Elvish includes a few other functions to help build completers:

- =edit:complete-filename= produces a listing of all the files and directories in the directory of its argument, and is the default completion function when no other completer is specified. See its [[https://elvish.io/ref/edit.html#editcomplete-filename][documentation]] for full details.
- =edit:complete-sudo= provides completions for commands like =sudo= which take a command as their first argument. It is the default completer for the =sudo= command, so that if you type =sudo= ~Space~ ~Tab~, you get a list of all the commands on your execution path. It can be reused for other commands, for example =time=:
  #+begin_src elvish
    edit:completion:arg-completer[time] = $edit:complete-sudo~
  #+end_src

Finally, note that if =$edit:completion:arg-completer['']= exists, it will be called as a fall-back completer if no command-specific argument completer exists. You can see that the default completer is =edit:complete-filename=, as mentioned before:

#+begin_src elvish
  ~> put $edit:completion:arg-completer['']
  ▶ $edit:complete-filename~
#+end_src

With the tools you know so far, you can already create fairly complex completers. In the next section, we will explore =comp=, an external library I wrote to make it easier to specify complex completion trees.

***** Complex completions using the =comp= framework

The built-in completion functions make it possible to build any completer you want. However, you might realize that for more complex cases, the specifications can be quite complex. For this reason, I wrote [[https://github.com/zzamboni/elvish-completions/blob/master/comp.org][the =comp= library]] as a framework to more easily specify completion functions. The basic Elvish mechanisms and functions are still used in the backend, so you can rest assured about their compatibility with the basic mechanisms.

As a first step, if you haven't done so already, you should install the =elvish-completions= package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish
  use epm
  epm:install github.com/zzamboni/elvish-completions
#+end_src

From the file where you will define your completions (or from your interactive session if you just want to play with it), load the =comp= module:

#+begin_src elvish
  use github.com/zzamboni/elvish-completions/comp
#+end_src

The main entry points for this module are =comp:item=, =comp:sequence= and =comp:subcommands=. Each one receives a single argument containing a  "completion definition", which indicates how the completions will be produced. Each one receives a different kind of completion structure, and returns a ready-to-use completion function, which can be assigned directly to an element of =$edit:completion:arg-completer=. A simple example:

#+begin_src elvish
  edit:completion:arg-completer[foo] = (comp:item [ bar baz ])
#+end_src

If you type this in your terminal, and then type =foo<space>= and press ~Tab~, you will see the appropriate completions:

#+begin_example
  > foo <Tab>
   COMPLETING argument _
   bar  baz
#+end_example

To create completions for new commands, your main task is to define the corresponding completion definition. The different types of definitions and functions are explained below, with examples of the different available structures and features.

*Note:* the main entry points return a ready-to-use argument handler function. If you ever need to expand a completion definition directly (maybe for some advanced usage), you can call =comp:-expand-item=, =comp:-expand-sequence= and =comp:-expand-subcommands=, respectively. These functions all take the definition structure and the current command line, and return the appropriate completions at that point.

We now look at the different types of completion definitions understood by =comp=.

****** Items

The base building block is the "item", can be one of the following:

- An array containing all the potential completions (it can be empty, in which case no completions are provided). This is useful for providing a static list of completions.
- A function which returns the potential completions (it can return nothing, in which case no completions are provided). The function should have one of the following arities, which affect which arguments will be passed to it (other arities are not valid, and in that case the item will not be executed):
  - If it takes no arguments, no arguments are passed to it.
  - If it takes a single argument, it gets the current (last) component of the command line =@cmd=; this is just like the handler functions understood by the =edit:complete-getopt= command.
  - If it takes a rest argument, it gets the full current command line (the contents of =@cmd=); this is just like the functions assigned to =$edit:completion:arg-completer=.

*Example #3:* a simple completer for =cd=

In this case, we define a function which receives the current "stem" (the part of the filename the user has typed so far) and offers all the relevant files, then filters those which are directories, and returns them as completion possibilities. We pass the function directly as a completion item to =comp:-expand=.

#+begin_src elvish
  fn complete-dirs [arg]{ put {$arg}* | each [x]{ if (-is-dir $x) { put $x } } }
  edit:completion:arg-completer[cd] = (comp:item $complete-dirs~)
#+end_src

For file and directory completion, you can use the utility function =comp:files= instead of defining your own function (see [[*Utility functions][Utility functions]]). =comp:files= uses =edit:complete-filename= in the backend but offers a few additional filtering options:

#+begin_src elvish
  edit:completion:arg-completer[cd] = (comp:item [arg]{ comp:files $arg &dirs-only })
#+end_src

****** Sequences and command-line options

Completion items can be aggregated in a /sequence of items/ and used with the =comp:sequence= function when you need to provide different completions for different positional arguments of a command, including support for command-line options at the beginning of the command (=comp:sequence= uses =edit:complete-getopt= in the backend, but provides a few additional convenient features). The definition structure in this case has to be an array of items, which will be applied depending on their position within the command parameter sequence. If the the last element of the list is the string =...= (three periods), the next-to-last element of the list is repeated for all later arguments. If no completions should be provided past the last argument, simply omit the periods. If a sequence should produce no completions at all, you can use an empty list =[]=. If any specific elements of the sequence should have no completions, you can specify ={ comp:empty }= or =[]= as its value.

If the =&opts= option is passed to the =comp:sequence= function, it must contain a single definition item which produces a list of command-line options that are allowed at the beginning of the command, when no other arguments have been provided. Options can be specified in either of the following formats:
- As a string which gets converted to a long-style option; e.g. =all= to specify the =--all= option. The string must not contain the dashes at the beginning.
- As a map in the style of =complete-getopt=, which may contain the following keys:
  - =short= for the short one-letter option;
  - =long= for the long-option string;
  - =desc= for a descriptive string which gets shown in the completion menu;
  - =arg-mandatory= or =arg-optional=: either one but not both can be set to =$true= to indicate whether the option takes a mandatory or optional argument;
  - =arg-completer= can be specified to produce completions for the option argument. If specified, it must contain completion item as described in [[*Items][Items]], and which will be expanded to provide completions for that argument's values.

Simple example of a completion data structure for option =-t= (long form =--type=), which has a mandatory argument which can be =elv=, =org= or =txt=:

#+begin_example
  [ &short=t
    &long=type
    &desc="Type of file to show"
    &arg-mandatory=$true
    &arg-completer= [ elv org txt ]
  ]
#+end_example

*Note:* options are only offered as completions when the use has typed a dash as the first character. Otherwise the argument completers are used.

*Example #4:* we can improve on the previous completer for =cd= by preventing more than one argument from being completed (only the first argument will be completed using =complete-dirs=, since the list does not end with =...=):

#+begin_src elvish
  edit:completion:arg-completer[cd] = (comp:sequence [ [arg]{ comp:files $arg &dirs-only }])
#+end_src

*Example #5:* a simple completer for =ls= with a subset of its options. Note that =-l= and =-R= are only provided as completions when you have not typed any filenames yet. Also note that we are using [[*Utility functions][comp:files]] to provide the file completions, and the =...= at the end of the sequence to use the same completer for all further elements.

#+begin_src elvish
  ls-opts = [
    [ &short=l                 &desc='use a long listing format' ]
    [ &short=R &long=recursive &desc='list subdirectories recursively' ]
  ]
  edit:completion:arg-completer[ls] = (comp:sequence &opts=$ls-opts [ $comp:files~ ... ])
#+end_src

*Example #6:* See the [[https://github.com/zzamboni/elvish-completions/blob/master/ssh.org][ssh completer]] for a real-world example of using sequences.

****** Subcommands

Finally, completion sequences can be aggregated into /subcommand structures/ using the =comp:subcommands= function, to provide completion for commands such as =git=, which accept multiple subcommands, each with their own options and completions. In this case, the definition is a map indexed by subcommand names. The value of each element can be a =comp:item=,  a =comp:sequence= or another =comp:subcommands= (to provide completion for sub-sub-commands, see the example below for =vagrant=). The =comp:subcommands= function can also receive the =&opts= option to generate any available top-level options.

*Example #7:* let us reimplement our completer for the =brew= package manager, but now with support for the =install=, =uninstall= and =cat= commands. =install= and =cat= gets as completions all available packages (the output of the =brew search= command), while =uninstall= only completes installed packages (the output of =brew list=). Note that for =install= and =uninstall= we automatically extract command-line options from their help messages using the =comp:extract-opts= function (wrapped into the =-brew-opts= function), and pass them as the =&opts= option in the corresponding sequence functions. Also note that all =&opts= elements get initialized at definition time (they are arrays), whereas the sequence completions get evaluated at runtime (they are lambdas), to automatically update according to the current packages. The =cat= command sequence allows only one option. The load-time initialization of the options incurs a small delay, and you could replace these with lambdas as well so that the options are computed at runtime. Note also the usage of the =comp:decorate= function to colorize the package names in different colors for each command.

#+begin_src elvish
  fn -brew-opts [cmd]{
    brew $cmd -h | take 1 | \
    comp:extract-opts &regex='--(\w[\w-]*)' &regex-map=[&long= 1]
  }
  brew-completions = [
    &install= (comp:sequence &opts= [ (-brew-opts install) ] \
      [ { brew search | comp:decorate &style=green } ... ]
    )
    &uninstall= (comp:sequence &opts= [ (-brew-opts uninstall) ] \
      [ { brew list | comp:decorate &style=red }   ... ]
    )
    &cat= (comp:sequence [{ brew search | comp:decorate &style=blue }])
  ]
  edit:completion:arg-completer[brew] = (comp:subcommands \
    &opts= [ version verbose ] $brew-completions
  )
#+end_src

Note that in contrast to our previous =brew= completer, this definition is much more expressive, accurate, and much easier to extend.

*Example #8:* a simple completer for a subset of =vagrant=, which receives commands which may have subcommands and options of their own. Note that the value of =&up= is a =comp:sequence=, but the value of =&box= is another =comp:subcommands= which includes the completions for =box add= and =box remove=. Also note the use of the =comp:extract-opts= function to extract the command-line arguments automatically from the help messages. The output of the =vagrant= help messages matches the default format expected by =comp:extract-opts=, so we don't even have to specify a regular expression like for =brew=.

*Tip:* note that the values of =&opts= are functions (e.g. ={ vagrant-up -h | comp:extract-opts }=) instead of arrays (e.g. =( vagrant up -h | comp:extract-opts )=). As mentioned in the previous example, both are valid, but in the latter case they are all initialized at load time (when the data structure is defined), which might introduce a delay, particularly with more command definitions. By using functions the options are only extracted at runtime when the completion is requested. For further optimization, =vagrant-opts= could be made to memoize the values so that the delay only occurs the first time.

#+begin_src elvish
  vagrant-completions = [
    &up= (comp:sequence [] \
      &opts= { vagrant up -h | comp:extract-opts }
    )
    &box= (comp:subcommands [
        &add= (comp:sequence [] \
          &opts= { vagrant box add -h | comp:extract-opts }
        )
        &remove= (comp:sequence [ { \
              vagrant box list | eawk [_ @f]{ put $f[0] } \
          } ... ] \
          &opts= { vagrant box remove -h | comp:extract-opts }
        )
  ])]

  edit:completion:arg-completer[vagrant] = (comp:subcommands \
    &opts= [ version help ] $vagrant-completions
  )
#+end_src

*Example #9:* See the [[https://github.com/zzamboni/elvish-completions/blob/master/git.org][git completer]] for a real-world subcommand completion example, which also shows how extensively auto-population of subcommands and options can be done by extracting information from help messages.

****** Utility functions

The =comp= module includes a few utility functions, some of which you have seen already in the examples.

=comp:decorate= maps its input through =edit:complex-candidate= with the given options. Can be passed the same options as [[https://elvish.io/ref/edit.html#argument-completer][edit:complex-candidate]]. In addition, if =&suffix= is specified, it is used to set both =&display-suffix= and =&code-suffix=. Input can be given either as arguments or through the pipeline:

#+begin_src elvish
  > comp:decorate &suffix=":" foo bar
  ▶ (edit:complex-candidate foo &code-suffix=: &display-suffix=: &style='')
  ▶ (edit:complex-candidate bar &code-suffix=: &display-suffix=: &style='')
  > put foo bar | comp:decorate &style="red"
  ▶ (edit:complex-candidate foo &code-suffix='' &display-suffix='' &style=31)
  ▶ (edit:complex-candidate bar &code-suffix='' &display-suffix='' &style=31)
#+end_src

=comp:extract-opts= takes input from the pipeline and extracts command-line option data structures from its output. By default it understand the following common formats:

#+begin_example
  -o, --option                Option description
  -p, --print[=<what>]        Option with an optional argument
      --select <type>         Option with a mandatory argument
#+end_example

Typical use would be to populate an =&opts= element with something like this:

#+begin_src elvish
  comp:sequence &opts= { vagrant -h | comp:extract-opts } [ ... ]
#+end_src

The regular expression used to extract the options can be specified with the =&regex= option. Its default value (which parses the common formats shown above) is:

#+begin_src elvish :noweb-ref opt-capture-regex
  &regex='^\s*(?:-(\w),?\s*)?(?:--?([\w-]+))?(?:\[=(\S+)\]|[ =](\S+))?\s*?\s\s(\w.*)$'
#+end_src

The mapping of capture groups from the regex to option components is defined by the =&regex-map= option. Its default value (which also shows the available fields) is:

#+begin_src elvish :noweb-ref opt-capture-map
  &regex-map=[&short=1 &long=2 &arg-optional=3 &arg-mandatory=4 &desc=5]
#+end_src

At least one of =short= or =long= must be present in =regex-map=. The =arg-optional= and =arg-mandatory= groups, if present, are handled specially: if any of them is not empty, then its contents is stored as =arg-desc= in the output, and the corresponding =arg-mandatory= / =arg-optional= is set to =$true=.

If =&fold= is =$true=, then the input is preprocessed to join option descriptions which span more than one line (the heuristic is not perfect and may not work in all cases, also for now it only joins one line after the option).

**** Contributing your completions


So you have created a brand-new completion function and would like to share it with the Elvish community. Nothing could be easier! You have two main options:

- Publish them on your own. For example, if you put your =.elv= files into their own repository in GitHub or Gitlab, they are ready to be installed and used using [[https://elvish.io/ref/epm.html][epm]].
- Contribute it to an existing repository (for example [[https://github.com/zzamboni/elvish-completions][elvish-completions]]). Just add your files, submit a pull request, and you are done.

I hope you have found this tutorial useful. Please let me know in the comments if you have any questions, feedback or if you find something that is incorrect.

Now, go have fun with Elvish!

** Other

*** TODO My blogging workflow with Emacs, org-mode+ox-hugo, Hugo and GitHub :blogging:howto:emacs:hugo:orgmode:github:
:PROPERTIES:
:export_file_name: my-blogging-workflow
:END:

My blogging has seen [[/about/#my-online-past][multiple iterations]] over the years, and with it, the tools I use have changed. At the moment I use a set of tools and workflows which make it very easy to keep my blog updated, and I will describe them in this post. In short, they are:

- *Writing:* Emacs, org-mode
- *Exporting:* ox-hugo
- *Publishing:* Hugo
- *Hosting:* GitHub Pages

Let's take a closer look at each of the stages.

**** Writing using Emacs and org-mode

I have been using Emacs for almost 30 years, so its use for me is second nature. However, I only recently started using [[https://orgmode.org/][org-mode]] for writing, blogging, coding, presentations and more, thanks to the hearty recommendations and information from [[http://www.cmdln.org/][Nick]] and many others. I am duly impressed. I have been a fan of the idea of [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] for many years, and I have tried other tools before (most notably [[https://www.cs.tufts.edu/~nr/noweb/][noweb]], which I used during grad school for many of my homeworks and projects), but org-mode is the first tool I have encountered which seems to make it practical. Here are some of the resources I have found useful in learning it:

- Howard Abrams' [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][Introduction to Literate Programming]], which got me jumpstarted into writing code documented with org-mode.
- Nick Anderson's [[https://github.com/nickanderson/Level-up-your-notes-with-Org][Level up your notes with Org]], which contains many useful tips and configuration tricks.
- Sacha Chua's [[http://sachachua.com/blog/2014/01/tips-learning-org-mode-emacs/][Some tips for learning Org Mode for Emacs]], her [[http://pages.sachachua.com/.emacs.d/Sacha.html][Emacs configuration]] and many of her [[http://sachachua.com/blog/category/emacs/][other articles]].
- Rainer König's [[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][OrgMode Tutorial]] video series.

You can see some examples in [[/tags/literateconfig/][my "literate config files" series]], and all recent posts in this blog are written using org-mode (you can find the [[https://github.com/zzamboni/zzamboni.org/blob/master/content-org/zzamboni.org][source file]] in GitHub).

Over time I have tweaked my Emacs configuration to make writing with org-mode more pleasant. You can see my tutorial on [[/post/beautifying-org-mode-in-emacs/][Beautifying org-mode in Emacs]], and also see the full [[/post/my-emacs-configuration-with-commentary/#org-mode][org-mode section of my Emacs config]] for reference.

So, I write posts using Emacs, in org-mode markup. What's next?

****  Exporting

When I first started writing my blog posts in org-mode, I relied on Hugo's [[https://gohugo.io/content-management/formats/][built-in support for it]], which allows you to simply create posts in =.org= files instead of =.md= and have them parse in org-mode format. Unfortunately, the support is not perfect. Hugo relies on the [[https://github.com/chaseadamsio/goorgeous][goorgeous]] library which, while quite powerful, does not support the full org-mode markup capabilities, so many elements are not rendered or processed properly.

Happily, I discovered [[https://ox-hugo.scripter.co/][ox-hugo]], an org-mode exporter which produces Hugo-ready Markdown files from the org-mode source, from which Hugo can produce the final HTML output. This is a much better arrangement, because each component handles only its native format: ox-hugo processes the org-mode source with the full support of org-mode and Emacs, and Hugo processes Markdown files, which are its native input format. You can use the full range of org-mode markup in your posts, and they will be correctly converted to their equivalents in Markdown. Furthermore, your source files remain output-agnostic, as you can still use all other org-mode exporters if you need to produce other formats.

Ox-hugo supports [[https://ox-hugo.scripter.co/#screenshot-one-post-per-subtree][two ways of organizing your posts]]: one post per org file, and one post per org subtree. In the first one, you write a separate org file for each post. In the second, you keep all your posts in a single org file, and specify (through org-mode properties) which subtrees should be exported as posts. The latter is the recommended way to organize posts. At first I was skeptical - who wants to keep everything in a single file? However, as I have worked more with it, I have come to realize its advantages. For one, it makes it easier to specify post metadata - for example, I have defined sections in [[https://github.com/zzamboni/zzamboni.org/blob/master/content-org/zzamboni.org][my org-mode source file]] for certain frequent topics, and those are tagged accordingly in the org source. When I create posts as subtrees of those sections, they inherit the top-level tags automatically, as well as any other properties, which I used to define (for example) the header images used in the posts. Having all posts in a single file also makes it easier to share other content, such as org macro definitions, ox-hugo configuration options, etc.

Note that ox-hugo is not limited to exporting blog posts, but any content processed by Hugo. For example, my org source file also includes all the static pages in my web site - they are differentiated from blog posts simply by the Hugo [[https://gohugo.io/content-management/sections/][section]] to which they belong, which is defined using the [[https://ox-hugo.scripter.co/doc/usage/#before-you-export][HUGO_SECTION property]], which is interpreted accordingly by ox-hugo.

Since the full power of org markup is available when using ox-hugo, you can do very interesting things. For example, all posts in my [[/tags/literateconfig/][Literate Config Files]] category are automatically updated every time I export them with the actual, real content of the corresponding config files, which I also keep in org format. There is a lot of hidden power in org-mode and ox-hugo. My recommendation is to go through the source files for some of the websites listed in ox-hugo's [[https://ox-hugo.scripter.co/doc/examples/][Real World Examples]] section. For example, I have learned a lot by reading through the source files for the [[https://github.com/kaushalmodi/ox-hugo/tree/master/doc][ox-hugo website]] itself.

**** Publishing

Once ox-hugo has generated the Markdown files for my posts, it is Hugo's turn to convert them into HTML files that can be published as a website. Ox-hugo knows the default structure expected by Hugo (a top-level =content/= directory in which you have directories for each section), so there's usually not much to do other than point ox-hugo to where your top-level Hugo directory is, using the [[https://ox-hugo.scripter.co/doc/usage/#before-you-export][HUGO_BASE_DIR]] property. Of course, this presumes you already have a Hugo site. If you have never used Hugo before, I would suggest you go through the [[http://gohugo.io/getting-started/quick-start/][Quick Start]] guide, which shows how to set up a basic website using the [[https://github.com/budparr/gohugo-theme-ananke][Ananke]] theme. This is the same theme I use for my website.

One particular piece of configuration I use to make publishing with GitHub pages easier: I change Hugo's =publishDir= parameter from its default value of =public= to =docs=, to make it easier to publish my final website from within the same repository (more below in the [[*Hosting][Hosting]] section). This is done by specifying the parameter in Hugo's [[https://github.com/zzamboni/zzamboni.org/blob/master/config.toml#L9][=config.toml=]] file:

#+begin_src conf-toml
  publishDir = "docs"
#+end_src

Hugo has extensive capabilities and it is beyond the scope of this article to show you how to use it, but it has [[https://gohugo.io/documentation/][very good documentation]] which I would urge you to peruse to learn more about it. Feel free to peruse [[https://github.com/zzamboni/zzamboni.org/blob/master/content-org/zzamboni.org][my setup]] for ideas.

**** Hosting

- Publishing from docs/
- Setting up SSL certificate

**** What's next?

- Automatic publishing using GitHub CI
- Maybe migrate to GitLab pages?


* Footnotes
* COMMENT Local Variables                                           :ARCHIVE:
# Local Variables:
# eval: (add-hook 'after-save-hook #'org-hugo-export-wim-to-md-after-save :append :local)
# End:
