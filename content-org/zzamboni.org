#+hugo_base_dir: ../
#+hugo_section: post
#+seq_todo: TODO DRAFT DONE

#+options: creator:t

* Ideas
** Hammerspoon
*** Using and extending Seal
*** Sending things to OmniFocus
** Elvish
** CFEngine
** Tips and tricks
*** CryFS
*** Hosting a Hugo blog in GitHub
Short guide to setting up Hugo, using /docs to host to avoid branches, and setting up your custom domain.
*** Using the Nix package manager in macOS
* Literate config files                   :config:howto:literateprogramming:
** DONE My Emacs Configuration, With Commentary                      :emacs:
CLOSED: [2017-12-17 Sun 20:14]
:properties:
:export_file_name: 2017-12-17-my-emacs-configuration-with-commentary
:export_hugo_custom_front_matter: :featured_image /images/emacs-logo.svg :toc true :summary I have enjoyed slowly converting my configuration files to literate programming style using org-mode in Emacs. It's now the turn of my Emacs configuration file.
:end:

Last update: *March 17th, 2018*

I have enjoyed slowly converting my configuration files to [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming]] style style using org-mode in Emacs. I previously posted my [[../my-elvish-configuration-with-commentary/][Elvish configuration]], and now it's the turn of my Emacs configuration file. The text below is included directly from my [[https://github.com/zzamboni/dot_emacs/blob/master/init.org][init.org]] file. Please note that the text below is a snapshot as the file stands as of the date shown above, but it is always evolving. See the [[https://github.com/zzamboni/dot_emacs/blob/master/init.org][init.org file in GitHub]] for my current, live configuration, and the generated file at [[https://github.com/zzamboni/dot_emacs/blob/master/init.el]].

*** Customized variables

Emacs has its own [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Easy-Customization.html#Easy-Customization][Customization mechanism]] for easily customizing many parameters. To make it easier to manage, I keep the customized variables and faces in a separate file and load it from the main file.

#+begin_src emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
#+end_src

Here is the current contents of the [[https://github.com/zzamboni/dot-emacs/blob/master/custom.el][custom.el]] file.

#+include: "custom.el" src emacs-lisp

*** Setting up the package system

I use the [[https://www.masteringemacs.org/article/spotlight-use-package-a-declarative-configuration-tool][wonderful =use-package= package]]. As this is not bundled yet with Emacs, the first thing we do is install it by hand. All other packages are then declaratively installed and configured with =use-package=. This makes it possible to fully bootstrap Emacs using only this config file, everything else is downloaded, installed and configured automatically.

First, we declare the package repositories to use.

#+begin_src emacs-lisp
  (setq package-archives '(("gnu"       . "https://elpa.gnu.org/packages/")
                           ("marmalade" . "https://marmalade-repo.org/packages/")
                           ("melpa"     . "https://melpa.org/packages/")
                           ;;("org"       . "http://orgmode.org/elpa/")
                           ))
#+end_src

Then we initialize the package system, refresh the list of packages and install =use-package= if needed.

#+begin_src emacs-lisp
  (package-initialize)

  (when (not package-archive-contents)
    (package-refresh-contents))

  (when (not (package-installed-p 'use-package))
    (package-install 'use-package))
#+end_src

We set some configuration for =use-package=.

#+begin_src emacs-lisp
  (require 'use-package)
  (setq use-package-always-ensure t)
  (setq use-package-verbose t)
#+end_src

This variable tells Emacs to prefer the =.el= file if it's newer, even if there is a corresponding =.elc= file. Also, use =auto-compile= to autocompile files as needed.

#+begin_src emacs-lisp
  (setq load-prefer-newer t)
  (use-package auto-compile
    :config (auto-compile-on-load-mode))
#+end_src

Set the load path to the directories from where I sometimes load things outside the package system. For now I am loading =org-mode= from a checkout of its git repository, so I load all its packages and the contrib packages from there.

#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/lisp/org-mode/lisp")
  (add-to-list 'load-path "~/.emacs.d/lisp/org-mode/contrib/lisp")
#+end_src

Before, I used to manually install the =org-plus-contrib= package. The code below is disabled for now, but kept here for reference.

#+begin_src emacs-lisp :noweb-ref none
  (when (not (package-installed-p 'org-plus-contrib))
    (package-install 'org-plus-contrib))
#+end_src

Load =org= right away, to avoid any interference with the version of =org= included with Emacs.

#+begin_src emacs-lisp
  (require 'org)
#+end_src

*** Settings
**** Proxy settings

These are two short functions I wrote to be able to set/unset proxy settings within Emacs. I haven't bothered to improve or automate this, as I pretty much only need it to be able to install packages sometimes when I'm at work. For now I just call them manually with =M-x set/unset-proxy= when I need to.

#+begin_src emacs-lisp
  (defun set-proxy ()
    (interactive)
    (setq url-proxy-services '(("http" . "proxy.corproot.net:8079")
                               ("https" . "proxy.corproot.net:8079"))))
  (defun unset-proxy ()
    (interactive)
    (setq url-proxy-services nil))
#+end_src

**** Miscellaneous settings

- This is probably one of my oldest settings - I remember adding it around 1993 when I started learning Emacs, and it has been in my config ever since. When =time-stamp= is run before every save, the string =Time-stamp: <>= in the first 8 lines of the file will be updated with the current timestamp.

  #+begin_src emacs-lisp
    (add-hook 'before-save-hook 'time-stamp)
  #+end_src

- When at the beginning of the line, make =Ctrl-K= remove the whole line, instead of just emptying it.

  #+begin_src emacs-lisp
    (setq kill-whole-line t)
  #+end_src

- Paste text where the cursor is, not where the mouse is.

  #+begin_src emacs-lisp
    (setq mouse-yank-at-point t)
  #+end_src

- Make completion case-insensitive.

  #+begin_src emacs-lisp
    (setq completion-ignore-case t)
    (setq read-file-name-completion-ignore-case t)
  #+end_src

- Show line numbers (disable for now because it causes performance issues in very large buffers).

  #+begin_src emacs-lisp
    ;; (global-linum-mode)
  #+end_src

- Highlight trailing whitespace in red, so it's easily visible

  #+begin_src emacs-lisp
    (setq-default show-trailing-whitespace t)
  #+end_src

- Highlight matching parenthesis

  #+begin_src emacs-lisp
    (show-paren-mode 1)
  #+end_src

- Don't use hard tabs

  #+begin_src emacs-lisp
    (setq-default indent-tabs-mode nil)
  #+end_src

- Emacs can automatically create backup files. This tells Emacs to [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html][put all backups in ~/.emacs.d/backups]].

  #+begin_src emacs-lisp
    (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
  #+end_src

- [[http://emacswiki.org/emacs/WinnerMode][WinnerMode]] makes it possible to cycle and undo window configuration changes (i.e. arrangement of panels, etc.)

  #+begin_src emacs-lisp
    (when (fboundp 'winner-mode) (winner-mode 1))
  #+end_src

- Add "unfill" commands to parallel the "fill" ones.

  #+begin_src emacs-lisp
    (use-package unfill)
  #+end_src

- Save the place of the cursor in each file, and restore it upon opening it again.

  #+begin_src emacs-lisp
    (use-package saveplace
      :config
      (setq-default save-place t)
      (setq save-place-file (concat user-emacs-directory "places")))
  #+end_src

- Provide mode-specific "bookmarks" - press =M-i= and you will be presented with a list of elements to which you can navigate - they can be headers in org-mode, function names in emacs-lisp, etc.

  #+begin_src emacs-lisp
    (use-package imenu-anywhere
      :config
      (global-set-key (kbd "M-i") 'ido-imenu-anywhere))
  #+end_src

- Smooth scrolling (line by line) instead of jumping by half-screens.

  #+begin_src emacs-lisp
    (use-package smooth-scrolling
      :config
      (smooth-scrolling-mode 1))
  #+end_src

- Delete trailing whitespace before saving a file.

  #+begin_src emacs-lisp
    (add-hook 'before-save-hook 'delete-trailing-whitespace)
  #+end_src

*** Keybindings
**** Miscellaneous keybindings

- =M-g= interactively asks for a line number and jump to it (=goto-line)=.

  #+begin_src emacs-lisp
    (global-set-key [(meta g)] 'goto-line)
  #+end_src

- =M-`= focuses the next frame, if multiple ones are active (emulate the Mac "next app window" keybinding)

  #+begin_src emacs-lisp
    (global-set-key [(meta \`)] 'other-frame)
  #+end_src

- Interactive search key bindings - make regex search the default. By default, =C-s= runs =isearch-forward=, so this swaps the bindings.

  #+begin_src emacs-lisp
    (global-set-key (kbd "C-s") 'isearch-forward-regexp)
    (global-set-key (kbd "C-r") 'isearch-backward-regexp)
    (global-set-key (kbd "C-M-s") 'isearch-forward)
    (global-set-key (kbd "C-M-r") 'isearch-backward)
  #+end_src

- Key binding to use "[[http://www.emacswiki.org/emacs/HippieExpand][hippie expand]]" for text autocompletion

  #+begin_src emacs-lisp
    (global-set-key (kbd "M-/") 'hippie-expand)
  #+end_src

**** Emulating vi's =%= key

One of the few things I missed in Emacs from vi was the =%= key, which jumps to the parenthesis, bracket or brace which matches the one below the cursor. This function implements the functionality. Inspired by [[http://www.emacswiki.org/emacs/NavigatingParentheses]], but modified to use =smartparens= instead of the default commands, and to work on brackets and braces.

#+begin_src emacs-lisp
  (defun goto-match-paren (arg)
    "Go to the matching paren/bracket, otherwise (or if ARG is not nil) insert %.
    vi style of % jumping to matching brace."
    (interactive "p")
    (if (not (memq last-command '(set-mark
                                  cua-set-mark
                                  goto-match-paren
                                  down-list
                                  up-list
                                  end-of-defun
                                  beginning-of-defun
                                  backward-sexp
                                  forward-sexp
                                  backward-up-list
                                  forward-paragraph
                                  backward-paragraph
                                  end-of-buffer
                                  beginning-of-buffer
                                  backward-word
                                  forward-word
                                  mwheel-scroll
                                  backward-word
                                  forward-word
                                  mouse-start-secondary
                                  mouse-yank-secondary
                                  mouse-secondary-save-then-kill
                                  move-end-of-line
                                  move-beginning-of-line
                                  backward-char
                                  forward-char
                                  scroll-up
                                  scroll-down
                                  scroll-left
                                  scroll-right
                                  mouse-set-point
                                  next-buffer
                                  previous-buffer
                                  previous-line
                                  next-line
                                  )))
        (self-insert-command (or arg 1))
      (cond ((looking-at "\\s\(") (sp-forward-sexp) (backward-char 1))
            ((looking-at "\\s\)") (forward-char 1) (sp-backward-sexp))
            (t (self-insert-command (or arg 1))))))
#+end_src

We bind this function to the =%= key.

#+begin_src emacs-lisp
  (global-set-key (kbd "%") 'goto-match-paren)
#+end_src

*** Org mode
:PROPERTIES:
:header-args: :noweb-ref org-mode-config
:END:

I have started using [[http://orgmode.org/][org-mode]] to writing, coding, presentations and more, thanks to the hearty recommendations and information from [[http://www.cmdln.org/][Nick]] and many others. I am duly impressed. I have been a fan of the idea of [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] for many years, and I have tried other tools before (most notably [[https://www.cs.tufts.edu/~nr/noweb/][noweb]], which I used during grad school for many of my homeworks and projects), but org-mode is the first tool I have encountered which seems to make it practical. Here are some of the resources I have found useful in learning it:

- Howard Abrams' [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][Introduction to Literate Programming]], which got me jumpstarted into writing code documented with org-mode.
- Nick Anderson's [[https://github.com/nickanderson/Level-up-your-notes-with-Org][Level up your notes with Org]], which contains many useful tips and configuration tricks.
- Sacha Chua's [[http://sachachua.com/blog/2014/01/tips-learning-org-mode-emacs/][Some tips for learning Org Mode for Emacs]], her [[http://pages.sachachua.com/.emacs.d/Sacha.html][Emacs configuration]] and many of her [[http://sachachua.com/blog/category/emacs/][other articles]].
- Rainer König's [[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][OrgMode Tutorial]] video series.

This is the newest and most-in-flux section of my Emacs config, since I'm still learning org-mode myself.

I use =use-package= to load the =org= package, and put all its Configuration inside the =:config= section (=<<org-mode-config>>= is replaced with all the org-related configuration blocks below).

#+begin_src emacs-lisp :noweb no-export :noweb-ref none
  (use-package org
    :ensure nil
    :load-path "~/.emacs.d/lisp/org-mode/lisp"
    :config
    <<org-mode-config>>)
#+end_src

**** Keybindings

Set up =C-c l= to store a link to the current org object, in counterpart to the default =C-c C-l= to insert a link.

#+begin_src emacs-lisp :tangle no
  (define-key global-map "\C-cl" 'org-store-link)
#+end_src

Set up =C-c a= to call up agenda mode.

#+begin_src emacs-lisp :tangle no
  (define-key global-map "\C-ca" 'org-agenda)
#+end_src

The default keybinding for =org-mark-element= is =M-h=, which in macOS hides the current application, so I bind it to =A-h=.

#+begin_src emacs-lisp :tangle no
  (define-key global-map (kbd "A-h") 'org-mark-element)
#+end_src

Load =org-tempo= to enable snippets such as =<s<TAB>= to insert a source block.

#+begin_src emacs-lisp :tangle no
  (require 'org-tempo)
#+end_src

**** General org-mode configuration

Set =org-directory= to a directory inside my Dropbox so that my main files get synchronized automatically.

#+begin_src emacs-lisp :tangle no
  (setq org-directory "~/Dropbox/org")
#+end_src

Automatically log done times in todo items (I haven't used this much yet).

#+begin_src emacs-lisp :tangle no
  (setq org-log-done t)
#+end_src

Keep the indentation well structured by. OMG this is a must have. Makes it feel less like editing a big text file and more like a purpose built editor for org mode that forces the indentation. Thanks [[https://github.com/nickanderson/Level-up-your-notes-with-Org/blob/master/Level-up-your-notes-with-Org.org#automatic-visual-indention][Nick]] for the tip!

#+begin_src emacs-lisp :tangle no
  (setq org-startup-indented t)
#+end_src

**** Building presentations with org-mode

[[https://github.com/yjwen/org-reveal][org-reveal]] is an awesome package for building presentations with org-mode.

#+begin_src emacs-lisp :tangle no
  ;; Set this to nil because a bug in ox-reveal otherwise breaks org-structure-template-alist
  (setq org-reveal-note-key-char nil)
  (use-package ox-reveal
    :config
    (setq org-reveal-root "file:///Users/taazadi1/Dropbox/org/reveal.js")
    (use-package htmlize))
#+end_src

**** Various exporters

One of the big strengths of org-mode is the ability to export a document in many different formats. Here I load some of the exporters I have found useful.

- Markdown

  #+begin_src emacs-lisp :tangle no
    (require 'ox-md)
  #+end_src

- [[https://github.com/stig/ox-jira.el][Jira markup]]. I also load =org-jira=, which provides a full interface to Jira through org-mode.

  #+begin_src emacs-lisp :tangle no
    (use-package ox-jira)
    (use-package org-jira
      :config
      ;; (setq jiralib-url "https://tracker.mender.io:443")
      (setq jiralib-url "https://jira.swisscom.com")
      (setq org-jira-working-dir "~/.org-jira"))
  #+end_src

- Confluence markup. This is included in org's contrib, so we just load it with =require= instead of =use-package=.

  #+begin_src emacs-lisp :tangle no
    (require 'ox-confluence)
  #+end_src

- AsciiDoc

  #+begin_src emacs-lisp :tangle no
    (use-package ox-asciidoc)
  #+end_src

- TexInfo. I have found that the best way to produce a PDF from an org file is to export it to a =.texi= file, and then use =texi2pdf= to produce the PDF.

  #+begin_src emacs-lisp :tangle no
    (require 'ox-texinfo)
  #+end_src

**** Keeping a Journal

I use [[http://750words.com/][750words]] for my personal Journal, and I usually write my entries locally using Scrivener. I have been playing with =org-journal= for this, but I am not fully convinced yet.

#+begin_src emacs-lisp :tangle no
  (use-package org-journal
    :config
    (setq org-journal-dir "~/Documents/logbook"))
#+end_src

**** Literate programming using org-babel

Org-mode is the first literate programming tool that seems practical and useful, since it's easy to edit, execute and document code from within the same tool (Emacs) using all of its existing capabilities (i.e. each code block can be edited in its native Emacs mode, taking full advantage of indentation, completion, etc.)

Plain literate programming is built-in, but the =ob-*= packages provide the ability to execute code in different languages, beyond those included with org-mode.

#+begin_src emacs-lisp :tangle no
  (use-package ob-cfengine3)
  (require 'ob-ruby)
  (require 'ob-latex)
  (require 'ob-plantuml)
  (setq org-plantuml-jar-path
        (expand-file-name "/usr/local/Cellar/plantuml/1.2017.18/libexec/plantuml.jar"))
  (require 'ob-python)
  (require 'ob-shell)
  (require 'ob-calc)
  (require 'ob-elvish)
#+end_src

=inf-ruby= makes =ob-ruby= more powerful by providing a persistent Ruby REPL.

#+begin_src emacs-lisp :tangle no
  (use-package inf-ruby)
#+end_src

This is potentially dangerous: it suppresses the query before executing code from within org-mode. I use it because I am very careful and only press =C-c C-c= on blocks I absolutely understand.

#+begin_src emacs-lisp :tangle no
  (setq org-confirm-babel-evaluate nil)
#+end_src

This makes it so that code within =src= blocks is fontified according to their corresponding Emacs mode, making the file much more readable.

#+begin_src emacs-lisp :tangle no
  (setq org-src-fontify-natively t)
#+end_src

In principle this makes it so that indentation in =src= blocks works as in their native mode, but in my experience it does not always work reliably. For full proper indentation, always edit the code in a native buffer by pressing =C-c '=.

#+begin_src emacs-lisp :tangle no
  (setq org-src-tab-acts-natively t)
#+end_src

Automatically show inline images, useful when executing code that produces them, such as PlantUML or Graphviz.

#+begin_src emacs-lisp :tangle no
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
#+end_src

This little snippet has revolutionized my literate programming workflow. It automatically runs =org-babel-tangle= upon saving any org-mode buffer, which means the resulting files will be automatically kept up to date.

#+begin_src emacs-lisp :tangle no
  (add-hook 'org-mode-hook
            (lambda () (add-hook 'after-save-hook 'org-babel-tangle
                                 'run-at-end 'only-in-org-mode)))
#+end_src

**** Beautifying org-mode

These settings make org-mode much more readable by using different fonts for headings, hiding some of the markup, etc. This was taken originally from http://www.howardism.org/Technical/Emacs/orgmode-wordprocessor.html and then tweaked by me.

#+begin_src emacs-lisp :tangle no
  (setq org-hide-emphasis-markers t)
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
  (use-package org-bullets
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
  (let* ((variable-tuple
          (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
                ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
                ((x-list-fonts "Verdana")         '(:font "Verdana"))
                ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
         (base-font-color     (face-foreground 'default nil 'default))
         (headline           `(:inherit default :weight bold :foreground ,base-font-color)))

    (custom-theme-set-faces
     'user
     `(org-level-8 ((t (,@headline ,@variable-tuple))))
     `(org-level-7 ((t (,@headline ,@variable-tuple))))
     `(org-level-6 ((t (,@headline ,@variable-tuple))))
     `(org-level-5 ((t (,@headline ,@variable-tuple))))
     `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
     `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
     `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
     `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
     `(org-document-title ((t (,@headline ,@variable-tuple :height 2.0 :underline nil))))))
#+end_src

I am experimenting with using proportional fonts in org-mode for the text, while keeping fixed-width fonts for blocks, so that source code, tables, etc. are shown correctly. I am currently playing with these settings, which include:

- Setting up =visual-line-mode= and making all my paragraphs one single line, so that the lines wrap around nicely in the window according to their proportional-font size, instead of at a fixed character count, which does not work so nicely when characters have varying widths.
- Setting up the =variable-pitch= face (I only learned of its existence now while figuring this out) to the proportional font I like to use. I'm currently using [[https://en.wikipedia.org/wiki/Source_Sans_Pro][Source Sans Pro]]. Another favorite is [[https://en.wikipedia.org/wiki/Avenir_(typeface)][Avenir Next]].
- Setting up the =fixed-pitch= face to be the same as my usual =default= face. My current one is [[https://en.wikipedia.org/wiki/Inconsolata][Inconsolata]].
- Configuring the corresponding org-mode faces for blocks, verbatim code, and maybe a couple of other things.
- Setting up a hook that automatically enables =visual-line-mode= and =variable-pitch-mode= when entering org-mode.

#+begin_src emacs-lisp :tangle no
  (add-hook 'org-mode-hook 'visual-line-mode)
  (add-hook 'org-mode-hook 'variable-pitch-mode)
#+end_src

**** Auto-generated table of contents

The =toc-org= package allows us to insert a table of contents in headings marked with =:TOC:=. This is useful for org files that are to be viewed directly on GitHub, which renders org files correctly, but does not generate a table of contents at the top. For an example, see [[https://github.com/zzamboni/dot-emacs/blob/master/init.org][this file on GitHub]].

Note that this breaks HTML export by default, as the links generated by =toc-org= cannot be parsed properly by the html exporter. The [[https://github.com/snosov1/toc-org/issues/35#issuecomment-275096511][workaround]] is to use =:TOC:noexport:= as the marker, which removed the generated TOC from the export, but still allows =ox-html= to insert its own TOC at the top.

#+begin_src emacs-lisp :tangle no
  (use-package toc-org
    :config
    (add-hook 'org-mode-hook 'toc-org-enable))
#+end_src

**** Grabbing links from different Mac applications

=org-mac-link= (included in contrib) implements the ability to grab links from different Mac apps and insert them in the file. Bind =C-c g= to call =org-mac-grab-link= to choose an application and insert a link.

#+begin_src emacs-lisp :tangle no
  (require 'org-mac-link)
  (add-hook 'org-mode-hook (lambda ()
                             (define-key org-mode-map (kbd "C-c g") 'org-mac-grab-link)))
#+end_src

**** Reformatting an org buffer

I picked up this little gem in the org mailing list. A function that reformats the current buffer by regenerating the text from its internal parsed representation. Quite amazing.

#+begin_src emacs-lisp :tangle no
  (defun org-reformat-buffer ()
    (interactive)
    (when (y-or-n-p "Really format current buffer? ")
      (let ((document (org-element-interpret-data (org-element-parse-buffer))))
        (erase-buffer)
        (insert document)
        (goto-char (point-min)))))
#+end_src

**** Snippets and templates

The [[https://github.com/Kungsgeten/yankpad][yankpad]] package makes it easy to store snippets that can be inserted at arbitrary points. Together with [[http://joaotavora.github.io/yasnippet/][yasnippet]] it becomes more powerful.

#+begin_src emacs-lisp
  (use-package yasnippet)
  (use-package yankpad
    :init
    (setq yankpad-file "~/Dropbox/org/yankpad.org")
    :config
    (bind-key "<f7>" 'yankpad-map)
    (bind-key "<f12>" 'yankpad-expand)
    ;; If you want to expand snippets with hippie-expand
    (add-to-list 'hippie-expand-try-functions-list #'yankpad-expand))
#+end_src

*** System-specific configuration

Some settings maybe OS-specific, and this is where we set them. For now I only use Emacs on my Mac, so only the Mac section is filled out, but there are sections for Linux and Windows as well.

#+begin_src emacs-lisp :noweb no-export
  (cond ((eq system-type 'darwin)
         <<Mac settings>>
         )
        ((eq system-type 'windows-nt)
         <<Windows settings>>
         )
        ((eq system-type 'gnu/linux)
         <<Linux settings>>
         ))
#+end_src

**** Mac

First, we set the key modifiers correctly to my preferences: Make Command (⌘) act as Meta, Option as Alt, right-Option as Super

#+name: Mac settings
#+begin_src emacs-lisp :tangle no
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier 'alt)
  (setq mac-right-option-modifier 'super)
#+end_src

We also make it possible to use the familiar =⌘-+= and =⌘--= to increase and decrease the font size. ⌘-= is also bound to "increase" because it's on the same key in an English keyboard.

#+name: Mac settings
#+begin_src emacs-lisp :tangle no
  (global-set-key (kbd "M-+") 'text-scale-increase)
  (global-set-key (kbd "M-=") 'text-scale-increase)
  (global-set-key (kbd "M--") 'text-scale-decrease)
#+end_src

Somewhat surprisingly, there seems to be no "reset" function, so I define my own and bind it to =⌘-0=.

#+name: Mac settings
#+begin_src emacs-lisp :tangle no
  (defun text-scale-reset ()
    (interactive)
    (text-scale-set 0))
  (global-set-key (kbd "M-0") 'text-scale-reset)
#+end_src

We also use the =exec-path-from-shell= to make sure the path settings from the shell are loaded into Emacs (usually it starts up with the default system-wide path).

#+name: Mac settings
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize))
#+end_src

**** Linux

There are no Linux-specific settings for now.

#+name: Linux settings

**** Windows

There are no Windows-specific settings for now.

#+name: Windows settings

*** Appearance, buffer/file management and theming

Here we take care of all the visual, UX and desktop-management settings.

The =diminish= package makes it possible to remove clutter from the modeline. Here we just load it, it gets enabled for individual packages in their corresponding declarations.

#+begin_src emacs-lisp
  (use-package diminish)
#+end_src

I have been playing with different themes, and I have settled for now in =gruvbox=. Some of my other favorites are also here so I don't forget about them.

#+begin_src emacs-lisp
  ;;(use-package solarized-theme)
  ;;(use-package darktooth-theme)
  ;;(use-package kaolin-themes)
  (use-package gruvbox-theme)
  (load-theme 'gruvbox)
#+end_src

Install [[https://github.com/Malabarba/smart-mode-line][smart-mode-line]] for modeline goodness.

#+begin_src emacs-lisp
  (use-package smart-mode-line
    :config
    (sml/setup))
#+end_src

Enable desktop-save mode, which saves the current buffer configuration on exit and reloads it on restart.

#+begin_src emacs-lisp
  (use-package desktop
    :config
    (desktop-save-mode 1))
#+end_src

The =uniquify= package makes it much easier to identify different open files with the same name by prepending/appending their directory or some other information to them. I configure it to add the directory name after the filename. =uniquify= is included in Emacs, so I specify =:ensure nil= so that =use-package= doesn't try to install it, and just loads and configures it.

#+begin_src emacs-lisp
  (use-package uniquify
    :ensure nil
    :config
    (setq uniquify-after-kill-buffer-p t)
    (setq uniquify-buffer-name-style 'post-forward)
    (setq uniquify-strip-common-suffix nil))
#+end_src

I like to highlight the current line and column. I'm still deciding between two approaches:

- Using the built-in =global-hl-mode= to always highlight the current line, together with the =col-highlight= package, which highlights the column only after a defined interval has passed
- Using the =crosshairs= package, which combines both but always highlights both the column and the line. It also has a "highlight crosshairs when idle" mode, but I prefer to have the current line always highlighted, I'm only undecided about the always-on column highlighting.

Sometimes I find the always-highlighted column to be distracting, but other times I find it useful. So I have both pieces of code here, I'm still deciding.

#+begin_src emacs-lisp :tangle no
  (global-hl-line-mode 1)
  (use-package col-highlight
    :config
    (col-highlight-toggle-when-idle)
    (col-highlight-set-interval 2))
  ;; (use-package crosshairs
  ;;   :config
  ;;   (crosshairs-mode))
#+end_src

I use [[https://www.masteringemacs.org/article/introduction-to-ido-mode][IDO mode]] to get better matching capabilities everywhere in Emacs.

#+begin_src emacs-lisp
  (use-package ido
    :config
    (ido-mode t)
    (ido-everywhere 1)
    (setq ido-use-virtual-buffers t)
    (setq ido-enable-flex-matching t)
    (setq ido-use-filename-at-point nil)
    (setq ido-auto-merge-work-directories-length -1))

  (use-package ido-completing-read+
    :config
    (ido-ubiquitous-mode 1))
#+end_src

I also use =recentf= to keep a list of recently open buffers, and define a function to trigger recentf with IDO integration, using =C-x C-r= as the keybinding.

#+begin_src emacs-lisp
  (use-package recentf
    :init
    (defun ido-recentf-open ()
      "Use `ido-completing-read' to \\[find-file] a recent file"
      (interactive)
      (if (find-file (ido-completing-read "Find recent file: " recentf-list))
          (message "Opening file...")
        (message "Aborting")))
    :config
    (recentf-mode 1)
    (setq recentf-max-menu-items 50)
    (global-set-key (kbd "C-x C-r") 'ido-recentf-open))
#+end_src

The [[http://martinowen.net/blog/2010/02/03/tips-for-emacs-ibuffer.html][ibuffer]] package allows all sort of useful operations on the list of open buffers. I haven't customized it yet, but I have a keybinding to open it.

#+begin_src emacs-lisp
  (use-package ibuffer
    :config
    (global-set-key (kbd "C-x C-b") 'ibuffer))
#+end_src

The [[https://github.com/nonsequitur/smex][smex]] package is incredibly useful, adding IDO integration and some other very nice features to =M-x=, which make it easier to discover and use Emacs commands. Highly recommended.

#+begin_src emacs-lisp
  (use-package smex
    :bind (("M-x" . smex))
    :config (smex-initialize))
#+end_src

[[https://www.emacswiki.org/emacs/MidnightMode][midnight-mode]] purges buffers which haven't been displayed in 3 days. We configure the period so that the cleanup happens every 2 hours (7200 seconds).

#+begin_src emacs-lisp
  (use-package midnight
    :config
    (setq midnight-mode 't)
    (setq midnight-period 7200))
#+end_src

For distraction-free writing, I'm testing out =writeroom-mode=.

#+begin_src emacs-lisp
  (use-package writeroom-mode)
#+end_src

[[https://github.com/jaypei/emacs-neotree][NeoTree]] shows a navigation tree on a sidebar, and allows a number of operations on the files and directories. I'm not much of a fan of this type of interface in Emacs, but I have set it up to check it out.

#+begin_src emacs-lisp
  (use-package neotree
    :config
    (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
    (setq neo-smart-open t)
    (setq projectile-switch-project-action 'neotree-projectile-action)
    (defun neotree-project-dir ()
      "Open NeoTree using the git root."
      (interactive)
      (let ((project-dir (projectile-project-root))
            (file-name (buffer-file-name)))
        (neotree-toggle)
        (if project-dir
            (if (neo-global--window-exists-p)
                (progn
                  (neotree-dir project-dir)
                  (neotree-find file-name)))
          (message "Could not find git project root."))))
    (global-set-key [f8] 'neotree-project-dir))
#+end_src

=wc-mode= allows counting characters and words, both on demand and continuously. It also allows setting up a word/character goal.

#+begin_src emacs-lisp
  (use-package wc-mode)
#+end_src

The =all-the-icons= package provides a number of useful icons.

#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src

*** Coding

Coding is my main use for Emacs, so it's understandably the largest section in my Emacs configuration.

**** General settings and modules

When enabled, =subword= allows navigating "sub words" individually in CamelCaseIdentifiers. For now I only enable it in =clojure-mode=.

#+begin_src emacs-lisp
  (use-package subword
    :config
    (add-hook 'clojure-mode-hook #'subword-mode))
#+end_src

With =aggressive-indent=, indentation is always kept up to date in the whole buffer. Sometimes it gets in the way, but in general it's nice and saves a lot of work, so I enable it for all programming modes.

#+begin_src emacs-lisp
  (use-package aggressive-indent
    :diminish aggressive-indent-mode
    :config
    (add-hook 'prog-mode-hook #'aggressive-indent-mode))
#+end_src

With =company-mode=, we get automatic completion - when there are completions available, a popup menu will appear when you stop typing for a moment, and you can either continue typing or accept the completion using the Enter key. I enable it globally.

#+begin_src emacs-lisp
  (use-package company
    :diminish company-mode
    :config
    (add-hook 'after-init-hook #'global-company-mode))
#+end_src

=projectile-mode= allows us to perform project-relative operations such as searches, navigation, etc.

#+begin_src emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :config
    (projectile-global-mode))
#+end_src

I find =iedit= absolutely indispensable when coding. In short: when you hit =Ctrl-:=, all occurrences of the symbol under the cursor (or the current selection) are highlighted, and any changes you make on one of them will be automatically applied to all others. It's great for renaming variables in code.

#+begin_src emacs-lisp
  (use-package iedit
    :config (set-face-background 'iedit-occurrence "Magenta"))
#+end_src

Turn on the online documentation mode for all programming modes (not all of them support it) and for the Clojure REPL =cider= mode.

#+begin_src emacs-lisp
  (use-package eldoc
    :config
    (add-hook 'prog-mode-hook #'turn-on-eldoc-mode)
    (add-hook 'cider-repl-mode-hook #'turn-on-eldoc-mode))
#+end_src

On-the-fly spell checking. I enable it for all text modes.

#+begin_src emacs-lisp
  (use-package flyspell
    :config
    (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word)
    (define-key flyspell-mouse-map [mouse-3] #'undefined)
    (add-hook 'text-mode-hook   'flyspell-mode))
#+end_src

**** Clojure and LISP coding

I dabble in Clojure and Emacs LISP, and Emacs has some fantastic support for them. There's a number of packages and configuration related to this, so I have a whole section for it.

The centerpiece is of course =clojure-mode=. In addition to files ending in =.clj=, I bind it automatically to =.boot= files (both by extension and by [[https://github.com/boot-clj/boot/wiki/For-Emacs-Users][shebang line]]) and to the [[http://riemann.io/][Riemann]] config files.

#+begin_src emacs-lisp
  (use-package clojure-mode
    :mode "\\.clj.*$"
    :mode "riemann.config"
    :mode "\\.boot"
    :config
    (add-to-list 'magic-mode-alist '(".* boot" . clojure-mode)))
#+end_src

Enable some additional fontification for Clojure code.

#+begin_src emacs-lisp
  (use-package clojure-mode-extra-font-locking)
#+end_src

The =cider= package provides a fantastic REPL built into Emacs. We configure a few aspects, including pretty printing, fontification, history size and others.

#+begin_src emacs-lisp
  (use-package cider
    :config
    ;; nice pretty printing
    (setq cider-repl-use-pretty-printing nil)

    ;; nicer font lock in REPL
    (setq cider-repl-use-clojure-font-lock t)

    ;; result prefix for the REPL
    (setq cider-repl-result-prefix "; => ")

    ;; never ending REPL history
    (setq cider-repl-wrap-history t)

    ;; looong history
    (setq cider-repl-history-size 5000)

    ;; persistent history
    (setq cider-repl-history-file "~/.emacs.d/cider-history")

    ;; error buffer not popping up
    (setq cider-show-error-buffer nil)

    ;; go right to the REPL buffer when it's finished connecting
    (setq cider-repl-pop-to-buffer-on-connect t))
#+end_src

We use =clj-refactor= for supporting advanced code refactoring in Clojure.

#+begin_src emacs-lisp
  (use-package clj-refactor
    :config
    (defun my-clojure-mode-hook ()
      (clj-refactor-mode 1)
      (yas-minor-mode 1) ; for adding require/use/import statements
      ;; This choice of keybinding leaves cider-macroexpand-1 unbound
      (cljr-add-keybindings-with-prefix "C-c C-m"))
    (add-hook 'clojure-mode-hook #'my-clojure-mode-hook))
#+end_src

Make the [[https://clojure.org/api/cheatsheet][Clojure cheatsheet]] available within Emacs when coding in Clojure.

#+begin_src emacs-lisp
  (use-package helm)
  (use-package clojure-cheatsheet
    :config
    (eval-after-load 'clojure-mode
      '(progn
         (define-key clojure-mode-map (kbd "C-c C-h") #'clojure-cheatsheet))))
#+end_src

When coding in LISP-like languages, =rainbow-delimiters= is a must-have - it marks each concentric pair of parenthesis with different colors, which makes it much easier to understand expressions and spot mistakes.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode))
#+end_src

Another useful addition for LISP coding - =smartparens= enforces parenthesis to match, and adds a number of useful operations for manipulating parenthesized expressions.

#+begin_src emacs-lisp
  (use-package smartparens
    :diminish smartparens-mode
    :config
    (require 'smartparens-config)
    (setq sp-base-key-bindings 'paredit)
    (add-hook 'clojure-mode-hook #'smartparens-strict-mode)
    (add-hook 'emacs-lisp-mode-hook #'smartparens-strict-mode)
    (add-hook 'lisp-mode-hook #'smartparens-strict-mode)
    (add-hook 'cider-repl-mode-hook #'smartparens-strict-mode))
#+end_src

Map =M-(= to enclose the next expression, as in =paredit=. Prefix argument can be used to indicate how many expressions to enclose instead of just 1. E.g. =C-u 3 M-(= will enclose the next 3 sexps.

#+begin_src emacs-lisp
  (defun sp-enclose-next-sexp (num) (interactive "p") (insert-parentheses (or num 1)))
  (add-hook 'smartparens-mode-hook #'sp-use-paredit-bindings)
  (add-hook 'smartparens-mode-hook (lambda () (local-set-key (kbd "M-(") 'sp-enclose-next-sexp)))
#+end_src

Minor mode for highlighting the current sexp in LISP modes.

#+begin_src emacs-lisp
  (use-package hl-sexp
    :config
    (add-hook 'clojure-mode-hook #'hl-sexp-mode)
    (add-hook 'lisp-mode-hook #'hl-sexp-mode)
    (add-hook 'emacs-lisp-mode-hook #'hl-sexp-mode))
#+end_src

Trying out [[https://github.com/abo-abo/lispy][lispy]] for LISP code editing (disabled for now).

#+begin_src emacs-lisp :tangle no
  (use-package lispy
    :config
    (defun enable-lispy-mode ()
      (lispy-mode 1))
    (add-hook 'clojure-mode-hook #'enable-lispy-mode)
    (add-hook 'emacs-lisp-mode-hook #'enable-lispy-mode)
    (add-hook 'common-lisp-mode-hook #'enable-lispy-mode)
    (add-hook 'scheme-mode-hook #'enable-lispy-mode)
    (add-hook 'lisp-mode-hook #'enable-lispy-mode))
#+end_src

I am sometimes trying out [[https://shaunlebron.github.io/parinfer/][parinfer]] (disabled for now).

#+begin_src emacs-lisp :tangle no
  (use-package parinfer
    :ensure t
    :bind
    (("C-," . parinfer-toggle-mode))
    :init
    (progn
      (setq parinfer-extensions
            '(defaults       ; should be included.
               pretty-parens  ; different paren styles for different modes.
               ;;evil           ; If you use Evil.
               lispy          ; If you use Lispy. With this extension, you should install Lispy and do not enable lispy-mode directly.
               paredit        ; Introduce some paredit commands.
               smart-tab      ; C-b & C-f jump positions and smart shift with tab & S-tab.
               smart-yank))   ; Yank behavior depend on mode.
      (add-hook 'clojure-mode-hook #'parinfer-mode)
      (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)
      (add-hook 'common-lisp-mode-hook #'parinfer-mode)
      (add-hook 'scheme-mode-hook #'parinfer-mode)
      (add-hook 'lisp-mode-hook #'parinfer-mode)))
#+end_src

**** Other programming languages

Many other programming languages are well served by a single mode, without so much setup as Clojure/LISP.

- [[http://cfengine.com/][CFEngine]] policy files.

  #+begin_src emacs-lisp
    (use-package cfengine
      :commands cfengine3-mode
      :mode ("\\.cf\\'" . cfengine3-mode))
  #+end_src

- [[https://www.perl.org/][Perl]].

  #+begin_src emacs-lisp
    (use-package cperl-mode
      :mode "\\.p[lm]\\'"
      :interpreter "perl"
      :config
      (setq cperl-hairy t))
  #+end_src

- [[http://fishshell.com/][Fish shell]].

  #+begin_src emacs-lisp
    (use-package fish-mode
      :mode "\\.fish\\'"
      :interpreter "fish")
  #+end_src

- [[https://www.lua.org/][Lua]], which I use for [[http://zzamboni.org/tags/hammerspoon/][Hammerspoon]] configuration.

  #+begin_src emacs-lisp
    (use-package lua-mode)
  #+end_src

- YAML, generally useful

  #+begin_src emacs-lisp
    (use-package yaml-mode)
  #+end_src

- AppleScript

  #+begin_src emacs-lisp
    (use-package applescript-mode)
  #+end_src

- Go

  #+begin_src emacs-lisp
    (use-package go-mode)
  #+end_src

- Check MELPA package definitions

  #+begin_src emacs-lisp
    (use-package package-lint)
  #+end_src

- [[http://elvish.io/][Elvish shell]]

  #+begin_src emacs-lisp
    (use-package elvish-mode)
  #+end_src

- [[https://racket-lang.org/][Racket]]

  #+begin_src emacs-lisp
    (use-package racket-mode)
  #+end_src

- [[https://nixos.org/nix/][Nix]] package files

  #+begin_src emacs-lisp
    (use-package nix-mode)
  #+end_src

*** Other tools

- git interface with some simple configuration I picked up somewhere

  #+begin_src emacs-lisp
    (use-package magit
      :config
      (defadvice magit-status (around magit-fullscreen activate)
        "Make magit-status run alone in a frame."
        (window-configuration-to-register :magit-fullscreen)
        ad-do-it
        (delete-other-windows))

      (defun magit-quit-session ()
        "Restore the previous window configuration and kill the magit buffer."
        (interactive)
        (kill-buffer)
        (jump-to-register :magit-fullscreen))

      (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)
      (global-set-key (kbd "C-c C-g") 'magit-status))
  #+end_src

- Interface to use the [[https://geoff.greer.fm/ag/][silver-searcher]]

  #+begin_src emacs-lisp
    (use-package ag)
  #+end_src

- Publishing with [[https://gohugo.io/][Hugo]]

  #+begin_src emacs-lisp
    (use-package easy-hugo
      :config
      (setq easy-hugo-basedir "~/Personal/devel/zzamboni.org/zzamboni.org/")
      (setq easy-hugo-url "http://zzamboni.org/")
      (setq easy-hugo-previewtime "300")
      (define-key global-map (kbd "C-c C-e") 'easy-hugo))
  #+end_src

- Function to randomize the order of lines in a region, from https://www.emacswiki.org/emacs/RandomizeBuffer.

  #+begin_src emacs-lisp
    (defun my-randomize-region (beg end)
      "Randomize lines in region from BEG to END."
      (interactive "*r")
      (let ((lines (split-string
                    (delete-and-extract-region beg end) "\n")))
        (when (string-equal "" (car (last lines 1)))
          (setq lines (butlast lines 1)))
        (apply 'insert
               (mapcar 'cdr
                       (sort (mapcar (lambda (x) (cons (random) (concat x "\n"))) lines)
                             (lambda (a b) (< (car a) (car b))))))))
  #+end_src

- [[https://www.gnu.org/software/emacs/manual/html_node/autotype/Autoinserting.html][auto-insert mode]] for automatically inserting user-defined templates for certain file types. It's included with Emacs, so I just configure its directory to one inside my Dropbox, and set the hook to run it automatically when opening a file.

  #+begin_src emacs-lisp
    (setq auto-insert-directory "~/Dropbox/emacs-auto-insert")
    (add-hook 'find-file-hook 'auto-insert)
  #+end_src

*** General text editing


In addition to coding, I configure some modes that can be used for text editing.

- [[http://asciidoctor.org/docs/user-manual/][AsciiDoc]], which I use for [[http://cf-learn.info/][my book]] and some other text.

  #+begin_src emacs-lisp
    (use-package adoc-mode
      :mode "\\.asciidoc\\'")
  #+end_src

- [[https://daringfireball.net/projects/markdown/syntax][Markdown]], generally useful.

  #+begin_src emacs-lisp
    (use-package markdown-mode)
  #+end_src

- When [[https://www.emacswiki.org/emacs/TypographicalPunctuationMarks][typopunct]] is enabled (needs to be enable by hand in my config), automatically inserts “pretty” quotes of the appropriate type.

  #+begin_src emacs-lisp
    (use-package typopunct
      :config
      (typopunct-change-language 'english t))
  #+end_src

*** Cheatsheet

How to do different things, not necessarily used in my Emacs config but useful sometimes.

This is how we get a global header property in org-mode

#+begin_src emacs-lisp :tangle no
  (alist-get :tangle
             (org-babel-parse-header-arguments
              (org-entry-get-with-inheritance "header-args")))
#+end_src
** DONE My Hammerspoon Configuration, With Commentary          :hammerspoon:
CLOSED: [2018-01-08 Mon 13:31]
:PROPERTIES:
:EXPORT_FILE_NAME: 2018-01-08-my-hammerspoon-configuration-with-commentary
:export_hugo_custom_front_matter: :toc true :featured_image /images/hammerspoon.png :summary In my ongoing series of literate config files, I present to you my Hammerspoon configuration file.
:END:

Last update: *March 18th, 2018*

In my [[../my-elvish-configuration-with-commentary/][ongoing]] [[../my-emacs-configuration-with-commentary][series]] of [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate]] config files, I present to you my [[http://www.hammerspoon.org/][Hammerspoon]] configuration file. You can see the generated file at [[https://github.com/zzamboni/dot-hammerspoon/blob/master/init.lua]]. As usual, this is just a snapshot at this time, you can see the current version of my configuration [[https://github.com/zzamboni/dot-hammerspoon/blob/master/init.org][in GitHub]].

*** General variables and configuration

Global log level. Per-spoon log level can be configured in each =Install:andUse= block below.

#+begin_src lua
  hs.logger.defaultLogLevel="info"
#+end_src

I use =hyper= and =shift_hyper= as the modifiers for most of my key bindings, so I define them as variables here for easier referencing.

#+begin_src lua
  hyper = {"cmd","alt","ctrl"}
  shift_hyper = {"cmd","alt","ctrl","shift"}
#+end_src

Set up an abbreviation for =hs.drawing.color.x11= since I use it repeatedly later on.

#+begin_src lua
  col = hs.drawing.color.x11
#+end_src

Work's logo, which I use in some of my Seal shortcuts later on.

#+begin_src lua
  swisscom_logo = hs.image.imageFromPath(hs.configdir .. "/files/swisscom_logo_2x.png")
#+end_src

*** Spoon Management

Set up SpoonInstall - this is the only spoon that needs to be manually installed (it is already there if you check out this repository), all the others are installed and configured automatically.

#+begin_src lua
  hs.loadSpoon("SpoonInstall")
#+end_src

Configuration of my personal spoon repository, which contains Spoons that have not been merged in the main repo.  See the descriptions at https://zzamboni.github.io/zzSpoons/.

#+begin_src lua
  spoon.SpoonInstall.repos.zzspoons = {
    url = "https://github.com/zzamboni/zzSpoons",
    desc = "zzamboni's spoon repository",
  }
#+end_src

I prefer sync notifications, makes them easier to read.

#+begin_src lua
  spoon.SpoonInstall.use_syncinstall = true
#+end_src

This is just a shortcut to make the declarations below look more readable, i.e. =Install:andUse= instead of =spoon.SpoonInstall:andUse=.

#+begin_src lua
  Install=spoon.SpoonInstall
#+end_src

*** URL Dispatching to site-specific browsers

The [[http://www.hammerspoon.org/Spoons/URLDispatcher.html][URLDispatcher]] spoon makes it possible to open URLs with different browsers. I have created different site-specific browsers using [[https://github.com/dmarmor/epichrome][Epichrome]], which allows me to keep site-specific bookmarks, search settings, etc.

#+begin_src lua
  Install:andUse("URLDispatcher",
                 {
                   config = {
                     url_patterns = {
                       { "https?://issue.swisscom.ch", "org.epichrome.app.SwisscomJira" },
                       { "https?://issue.swisscom.com", "org.epichrome.app.SwisscomJira" },
                       { "https?://jira.swisscom.com", "org.epichrome.app.SwisscomJira" },
                       { "https?://wiki.swisscom.com", "org.epichrome.app.SwisscomWiki" },
                       { "https?://collaboration.swisscom.com", "org.epichrome.app.SwisscomCollab" },
                       { "https?://smca.swisscom.com", "org.epichrome.app.SwisscomTWP" },
                       { "https?://portal.corproot.net", "com.google.Chrome" },
                       { "https?://app.opsgenie.com", "org.epichrome.app.OpsGenie" },
                     },
                     default_handler = "com.google.Chrome"
                   },
                   start = true
                 }
  )
#+end_src

*** Window and screen manipulation

The [[http://www.hammerspoon.org/Spoons/WindowHalfsAndThirds.html][WindowHalfAndThirds]] spoon sets up multiple key bindings for manipulating the size and position of windows.

#+begin_src lua
  Install:andUse("WindowHalfsAndThirds",
                 {
                   config = {
                     use_frame_correctness = true
                   },
                   hotkeys = 'default'
                 }
  )
#+end_src

The [[http://zzamboni.org/zzSpoons/WindowScreenLeftAndRight.html][WindowScreenLeftAndRight]] spoon sets up key bindings for moving windows between multiple screens.

#+begin_src lua
  Install:andUse("WindowScreenLeftAndRight",
                 {
                   hotkeys = 'default'
                 }
  )
#+end_src

The [[http://www.hammerspoon.org/Spoons/WindowGrid.html][WindowGrid]] spoon sets up a key binding (=Hyper-g= here) to overlay a grid that allows resizing windows by specifying their opposite corners.

#+begin_src lua
  Install:andUse("WindowGrid",
                 {
                   config = { gridGeometries = { { "6x4" } } },
                   hotkeys = {show_grid = {hyper, "g"}},
                   start = true
                 }
  )
#+end_src

The [[http://www.hammerspoon.org/Spoons/ToggleScreenRotation.html][ToggleScreenRotation]] spoon sets up a key binding to rotate the external screen (the spoon can set up keys for multiple screens if needed, but by default it rotates the first external screen).

#+begin_src lua
  Install:andUse("ToggleScreenRotation",
                 {
                   hotkeys = { first = {hyper, "f15"} }
                 }
  )
#+end_src

*** Organization and Productivity

The [[http://www.hammerspoon.org/Spoons/UniversalArchive.html][UniversalArchive]] spoon sets up a single key binding (=Ctrl-Cmd-a=) to archive the current item in Evernote, Mail and Outlook.

#+begin_src lua
  Install:andUse("UniversalArchive",
                 {
                   config = {
                     evernote_archive_notebook = ".Archive",
                     outlook_archive_folder = "Archive (On My Computer)",
                     archive_notifications = false
                   },
                   hotkeys = { archive = { { "ctrl", "cmd" }, "a" } }
                 }
  )
#+end_src

The [[http://www.hammerspoon.org/Spoons/SendToOmniFocus.html][SendToOmniFocus]] spoon sets up a single key binding (=Hyper-t=) to send the current item to OmniFocus from multiple applications.

#+begin_src lua
  Install:andUse("SendToOmniFocus",
                 {
                   config = {
                     quickentrydialog = false,
                     notifications = false
                   },
                   hotkeys = {
                     send_to_omnifocus = { hyper, "t" }
                   },
                   fn = function(s)
                     s:registerApplication("Swisscom Collab", { apptype = "chromeapp", itemname = "tab" })
                     s:registerApplication("Swisscom Wiki", { apptype = "chromeapp", itemname = "wiki page" })
                     s:registerApplication("Swisscom Jira", { apptype = "chromeapp", itemname = "issue" })
                   end
                 }
  )
#+end_src

The [[http://www.hammerspoon.org/Spoons/EvernoteOpenAndTag.html][EvernoteOpenAndTag]] spoon sets up some missing key bindings for note manipulation in Evernote.

#+begin_src lua
  Install:andUse("EvernoteOpenAndTag",
                 {
                   hotkeys = {
                     open_note = { hyper, "o" },
                     ["open_and_tag-+work,+swisscom"] = { hyper, "w" },
                     ["open_and_tag-+personal"] = { hyper, "p" },
                     ["tag-@zzdone"] = { hyper, "z" }
                   }
                 }
  )
#+end_src

The [[http://www.hammerspoon.org/Spoons/TextClipboardHistory.html][TextClipboardHistory]] spoon implements a clipboard history, only for text items. It is invoked with =Cmd-Shift-v=.

#+begin_src lua
  Install:andUse("TextClipboardHistory",
                 {
                   config = {
                     show_in_menubar = false,
                   },
                   hotkeys = {
                     toggle_clipboard = { { "cmd", "shift" }, "v" } },
                   start = true,
                 }
  )
#+end_src

*** System and UI

The [[https://zzamboni.github.io/zzSpoons/Hammer.html][Hammer]] spoon (get it? hehe) is a simple wrapper around some common Hamerspoon configuration variables. Note that this gets loaded from my personal repo, since it's not in the official repository.

#+begin_src lua
  Install:andUse("Hammer",
                 {
                   repo = 'zzspoons',
                   config = { auto_reload_config = false },
                   hotkeys = {
                     config_reload = {hyper, "r"},
                     toggle_console = {hyper, "y"}
                   },
                   start = true
                 }
  )
#+end_src

The [[http://www.hammerspoon.org/Spoons/Caffeine.html][Caffeine]] spoon allows preventing the display and the machine from sleeping. I use it frequently when playing music from my machine, to avoid having to unlock the screen whenever I want to change the music.

#+begin_src lua
  Install:andUse("Caffeine", {
                   start = true,
                   hotkeys = {
                     toggle = { hyper, "1" }
                   }
  })
#+end_src

The [[http://www.hammerspoon.org/Spoons/MenubarFlag.html][MenubarFlag]] spoon colorizes the menubar according to the selected keyboard language or layout (functionality inspired by [[https://pqrs.org/osx/ShowyEdge/index.html.en][ShowyEdge]]). I use English, Spanish and German, so those are the colors I have defined.

#+begin_src lua
  Install:andUse("MenubarFlag",
                 {
                   config = {
                     colors = {
                       ["U.S."] = { },
                       Spanish = {col.green, col.white, col.red},
                       German = {col.black, col.red, col.yellow},
                     }
                   },
                   start = true
                 }
  )
#+end_src

The [[http://www.hammerspoon.org/Spoons/MouseCircle.html][MouseCircle]] spoon shows a circle around the mouse pointer when triggered. I have it disabled for now because I have the macOS [[https://support.apple.com/kb/PH25507?locale=en_US&viewlocale=en_US][shake-to-grow feature]] enabled.

#+begin_src lua
  Install:andUse("MouseCircle",
                 {
                   disable = true,
                   config = {
                     color = hs.drawing.color.x11.rebeccapurple
                   },
                   hotkeys = {
                     show = { hyper, "m" }
                   }
                 }
  )
#+end_src

One of my original bits of Hammerspoon code, now made into a spoon (although I keep it disabled, since I don't really use it). The [[http://www.hammerspoon.org/Spoons/ColorPicker.html][ColorPicker]] spoon shows a menu of the available color palettes, and when you select one, it draws swatches in all the colors in that palette, covering the whole screen. You can click on any of them to copy its name to the clipboard, or cmd-click to copy its RGB code.

#+begin_src lua
  Install:andUse("ColorPicker",
                 {
                   disable = true,
                   hotkeys = {
                     show = { shift_hyper, "c" }
                   },
                   config = {
                     show_in_menubar = false,
                   },
                   start = true,
                 }
  )
#+end_src

I use Homebrew, and when I run =brew update=, I often wonder about what some of the formulas shown are (names are not always obvious). The [[http://www.hammerspoon.org/Spoons/BrewInfo.html][BrewInfo]] spoon allows me to point at a Formula or Cask name and press =Hyper-b= or =Hyper-c= (for Casks) to have the output of the =info= command in a popup window, or the same key with =Shift-Hyper= to open the URL of the Formula/Cask.

#+begin_src lua
  Install:andUse("BrewInfo",
                 {
                   config = {
                     brew_info_style = {
                       textFont = "Inconsolata",
                       textSize = 14,
                       radius = 10 }
                   },
                   hotkeys = {
                     -- brew info
                     show_brew_info = {hyper, "b"},
                     open_brew_url = {shift_hyper, "b"},
                     -- brew cask info
                     show_brew_cask_info = {hyper, "c"},
                     open_brew_cask_url = {shift_hyper, "c"},
                   }
                 }
  )
#+end_src

The [[http://www.hammerspoon.org/Spoons/KSheet.html][KSheet]] spoon traverses the current application's menus and builds a cheatsheet of the keyboard shortcuts, showing it in a nice popup window.

#+begin_src lua
  Install:andUse("KSheet",
                 {
                   hotkeys = {
                     toggle = { hyper, "/" }
  }})
#+end_src

The [[http://www.hammerspoon.org/Spoons/TimeMachineProgress.html][TimeMachineProgress]] spoon shows an indicator about the progress of the ongoing Time Machine backup. The indicator disappears when there is no backup going on.

#+begin_src lua
  Install:andUse("TimeMachineProgress",
                 {
                   start = true
                 }
  )
#+end_src

*** Other applications

The [[http://www.hammerspoon.org/Spoons/ToggleSkypeMute.html][ToggleSkypeMute]] spoon sets up the missing keyboard bindings for toggling the mute button on Skype and Skype for Business. I'm not fully happy with this spoon - it should auto-detect the application instead of having separate keys for each application, and it could be extended to more generic use.

#+begin_src lua
  Install:andUse("ToggleSkypeMute",
                 {
                   hotkeys = {
                     toggle_skype = { shift_hyper, "v" },
                     toggle_skype_for_business = { shift_hyper, "f" }
                   }
                 }
  )
#+end_src

The [[http://www.hammerspoon.org/Spoons/HeadphoneAutoPause.html][HeadphoneAutoPause]] spoon implements auto-pause/resume for iTunes, Spotify and others when the headphones are unplugged.

#+begin_src lua
  Install:andUse("HeadphoneAutoPause",
                 {
                   start = true
                 }
  )
#+end_src

*** Seal

The [[http://www.hammerspoon.org/Spoons/Seal.html][Seal]] spoon is a powerhouse - it implements a Spotlight-like launcher, but which allows for infinite configurability of what can be done or searched from the launcher window. I use Seal as my default launcher, triggered with =Cmd-space=, although I still keep Spotlight around under =Hyper-space=, mainly for its search capabilities.

We start by loading the spoon, and specifying which plugins we want.

#+begin_src lua :noweb no-export
  Install:andUse("Seal",
                 {
                   hotkeys = { show = { {"cmd"}, "space" } },
                   fn = function(s)
                     s:loadPlugins({"apps", "calc", "safari_bookmarks", "screencapture", "useractions"})
                     s.plugins.safari_bookmarks.always_open_with_safari = false
                     s.plugins.useractions.actions =
                       {
                        <<useraction-definitions>>
                       }
                     s:refreshAllCommands()
                   end,
                   start = true,
                 }
  )
#+end_src

The =useractions= Seal plugin allows me to define my own shortcuts. For example, a bookmark to the Hammerspoon documentation page:

#+begin_src lua :tangle no :noweb-ref useraction-definitions
  ["Hammerspoon docs webpage"] = {
    url = "http://hammerspoon.org/docs/",
    icon = hs.image.imageFromName(hs.image.systemImageNames.ApplicationIcon),
  },
#+end_src

Or to manually trigger my work/non-work transition scripts (see below):

#+begin_src lua :tangle no :noweb-ref useraction-definitions
  ["Leave corpnet"] = {
    fn = function()
      spoon.WiFiTransitions:processTransition('foo', 'corpnet01')
    end,
    icon = swisscom_logo,
  },
  ["Arrive in corpnet"] = {
    fn = function()
      spoon.WiFiTransitions:processTransition('corpnet01', 'foo')
    end,
    icon = swisscom_logo,
  },
#+end_src

Or to translate things using [[https://dict.leo.org/][dict.leo.org]]:

#+begin_src lua :tangle no :noweb-ref useraction-definitions
  ["Translate using Leo"] = {
    url = "http://dict.leo.org/ende/index_de.html#/search=${query}",
    icon = 'favicon',
    keyword = "leo",
  }
#+end_src

*** Network transitions

The [[http://www.hammerspoon.org/Spoons/WiFiTransitions.html][WiFiTransitions]] spoon allows triggering arbitrary actions when the SSID changes. I am interested in the change from my work network (corpnet01) to other networks, mainly because at work I need a proxy for all connections to the Internet. I have two applications which don't handle these transitions gracefully on their own: Spotify and Adium. So I have written a couple of functions for helping them along.

The =reconfigSpotifyProxy= function quits Spotify, updates the proxy settings in its config file, and restarts it.

#+begin_src lua
  function reconfigSpotifyProxy(proxy)
    local spotify = hs.appfinder.appFromName("Spotify")
    local lastapp = nil
    if spotify then
      lastapp = hs.application.frontmostApplication()
      spotify:kill()
      hs.timer.usleep(40000)
    end
    --   hs.notify.show(string.format("Reconfiguring %sSpotify", ((spotify~=nil) and "and restarting " or "")), string.format("Proxy %s", (proxy and "enabled" or "disabled")), "")
    -- I use CFEngine to reconfigure the Spotify preferences
    cmd = string.format("/usr/local/bin/cf-agent -K -f %s/files/spotify-proxymode.cf%s", hs.configdir, (proxy and " -DPROXY" or " -DNOPROXY"))
    output, status, t, rc = hs.execute(cmd)
    if spotify and lastapp then
      hs.timer.doAfter(3,
                       function()
                         if not hs.application.launchOrFocus("Spotify") then
                           hs.notify.show("Error launching Spotify", "", "")
                         end
                         if lastapp then
                           hs.timer.doAfter(0.5, hs.fnutils.partial(lastapp.activate, lastapp))
                         end
      end)
    end
  end
#+end_src

The =reconfigAdiumProxy= function uses AppleScript to tell Adium about the change without having to restart it.

#+begin_src lua
  function reconfigAdiumProxy(proxy)
    --   hs.notify.show("Reconfiguring Adium", string.format("Proxy %s", (proxy and "enabled" or "disabled")), "")
    local script = string.format([[
  tell application "Adium"
    repeat with a in accounts
      if (enabled of a) is true then
        set proxy enabled of a to %s
      end if
    end repeat
    go offline
    go online
  end tell
  ]], hs.inspect(proxy))
    hs.osascript.applescript(script)
  end
#+end_src

The configuration for the WiFiTransitions spoon invoked these functions with the appropriate parameters.

#+begin_src lua
  Install:andUse("WiFiTransitions",
                 {
                   config = {
                     actions = {
                       -- { -- Test action just to see the SSID transitions
                       --    fn = function(_, _, prev_ssid, new_ssid)
                       --       hs.notify.show("SSID change", string.format("From '%s' to '%s'", prev_ssid, new_ssid), "")
                       --    end
                       -- },
                       { -- Enable proxy in Spotify and Adium config when joining corp network
                         to = "corpnet01",
                         fn = {hs.fnutils.partial(reconfigSpotifyProxy, true),
                               hs.fnutils.partial(reconfigAdiumProxy, true),
                         }
                       },
                       { -- Disable proxy in Spotify and Adium config when leaving corp network
                         from = "corpnet01",
                         fn = {hs.fnutils.partial(reconfigSpotifyProxy, false),
                               hs.fnutils.partial(reconfigAdiumProxy, false),
                         }
                       },
                     }
                   },
                   start = true,
                 }
  )
#+end_src

*** Pop-up translation

I live in Switzerland, and my German is far from perfect, so the [[http://www.hammerspoon.org/Spoons/PopupTranslateSelection.html][PopupTranslateSelection]] spoon helps me a lot. It allows me to select some text and, with a keystroke, translate it to any of three languages using Google Translate. Super useful! Usually, Google's auto-detect feature works fine, so the =translate_to_<lang>= keys are sufficient. I have some =translate_<from>_<to>= keys set up for certain language pairs for when this doesn't quite work (I don't think I've ever needed them).

#+begin_src lua
  local wm=hs.webview.windowMasks
  Install:andUse("PopupTranslateSelection",
                 {
                   config = {
                     popup_style = wm.utility|wm.HUD|wm.titled|wm.closable|wm.resizable,
                   },
                   hotkeys = {
                     translate_to_en = { hyper, "e" },
                     translate_to_de = { hyper, "d" },
                     translate_to_es = { hyper, "s" },
                     translate_de_en = { shift_hyper, "e" },
                     translate_en_de = { shift_hyper, "d" },
                   }
                 }
  )
#+end_src

*** Miscellaneous stuff

In my =init-local.lua= file I keep some experimental or private stuff that I don't want to publish in my main config.

#+begin_src lua
  local localstuff=loadfile(hs.configdir .. "/init-local.lua")
  if localstuff then
    localstuff()
  end
#+end_src

*** End-of-config animation

The [[http://www.hammerspoon.org/Spoons/FadeLogo.html][FadeLogo]] spoon simply shows an animation of the Hammerspoon logo to signal the end of the config load.

#+begin_src lua
  Install:andUse("FadeLogo",
                 {
                   config = {
                     default_run = 1.0,
                   },
                   start = true
                 }
  )
#+end_src

If you don't want to use FadeLogo, you can have a regular notification.

#+begin_src lua
  -- hs.notify.show("Welcome to Hammerspoon", "Have fun!", "")
#+end_src
** DONE My Elvish Configuration With Commentary             :elvish:
CLOSED: [2017-11-16 Thu 20:21]
:PROPERTIES:
:export_file_name: 2017-11-16-my-elvish-configuration-with-commentary
:export_hugo_custom_front_matter: :toc true :featured_image /images/elvish-logo.svg :summary In this blog post I will walk you through my current Elvish configuration file, with running commentary about the different sections.
:END:

Last update: *March 18th, 2018*

In this blog post I will walk you through my current [[http://elvish.io][Elvish]] configuration file, with running commentary about the different sections.

This is also my first blog post written using [[http://orgmode.org/][org-mode]], which I have started using for writing and documenting my code, using [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming]]. The content below is included unmodified from my [[https://github.com/zzamboni/vcsh_elvish/blob/master/.elvish/rc.org][rc.org file]], from which the [[https://github.com/zzamboni/vcsh_elvish/blob/master/.elvish/rc.elv][rc.elv]] file is directly generated.

Without further ado...

*** Paths

First we set up the executable paths. We set the ~GOPATH~ environment variable while we are at it, since we need to use it as part of the path.

#+begin_src elvish
  E:GOPATH = ~/Personal/devel/go/
  paths = [
    ~/bin
    $E:GOPATH/bin
    ~/Dropbox/Personal/devel/hammerspoon/spoon/bin
    ~/.gem/ruby/2.4.0/bin
    /opt/X11/bin
    /Library/TeX/texbin
    /usr/local/bin
    /usr/local/sbin
    /usr/sbin
    /sbin
    /usr/bin
    /bin
  ]
#+end_src

*** Package installation

The bundled [[https://elvish.io/ref/epm.html][epm]] module allows us to install and manage Elvish packages.

#+begin_src elvish
  use epm
#+end_src

For now I use these packages:

- [[https://github.com/zzamboni/elvish-modules][github.com/zzamboni/elvish-modules]] contains all my modules except completions and themes. Maybe these should be separated eventually, but for now this works fine.
- [[https://github.com/zzamboni/elvish-themes][github.com/zzamboni/elvish-themes]] contains my prompt themes (only [[https://github.com/zzamboni/elvish-themes/blob/master/chain.org][chain]] for now).
- [[https://github.com/zzamboni/elvish-completions][github.com/zzamboni/elvish-completions]] contains my completer definitions.
- [[https://github.com/xiaq/edit.elv][github.com/xiaq/edit.elv]], which includes the =smart-matcher= module used below.
- [[https://github.com/muesli/elvish-libs][github.com/muesli/elvish-libs]] for the git utilities module.

#+begin_src elvish
  epm:install &silent-if-installed=$true   \
    github.com/zzamboni/elvish-modules     \
    github.com/zzamboni/elvish-completions \
    github.com/zzamboni/elvish-themes      \
    github.com/xiaq/edit.elv               \
    github.com/muesli/elvish-libs
#+end_src

The modules within each package get loaded individually below.

*** Base modules

Load the bundled [[https://elvish.io/ref/re.html][re]] module to have access to regular expression functions.

#+begin_src elvish
  use re
#+end_src

The bundled [[https://elvish.io/ref/bundled.html][readline-binding]] module associates some Emacs-like keybindings for manipulation of the command line.

#+begin_src elvish
  use readline-binding
#+end_src

I add a couple of keybindings which are missing from the default =readline-binding= module:

- =Alt-backspace= to delete word

  #+begin_src elvish
    edit:insert:binding[Alt-Backspace] = $edit:kill-small-word-left~
  #+end_src

- =Alt-d= to delete the word under the cursor

  #+begin_src elvish
    edit:insert:binding[Alt-d] = { edit:move-dot-right-word; edit:kill-word-left }
  #+end_src

*** Git utilities

I use muesli's git utilities module.

#+begin_src elvish
  use github.com/muesli/elvish-libs/git
#+end_src

*** Aliases

Elvish does not have built-in alias functionality, but this is implemented easily using the [[https://github.com/zzamboni/modules.elv/blob/master/alias.org][alias]] module, which stores the alias definitions as functions under [[https://github.com/zzamboni/dot-elvish/tree/master/aliases][~/.elvish/aliases/]] and loads them automatically.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/alias
#+end_src

For reference, I define here a few of my commonly-used aliases:

#+begin_src elvish
  alias:new dfc e:dfc -W -l -p -/dev/disk1s4,devfs
  alias:new ls e:ls --color=auto
  alias:new more less
  alias:new v vagrant
#+end_src

*** Nix package manager

I use the [[https://nixos.org/nix/][Nix]] package manager on macOS, the [[https://github.com/zzamboni/modules.elv/blob/master/nix.org][nix]] module sets up the necessary environment variables.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/nix
  nix:multi-user-setup
#+end_src

*** Completions

From the  [[https://github.com/zzamboni/elvish-completions][elvish-completions]] package:

For =git=:

#+begin_src elvish
  use github.com/zzamboni/elvish-completions:git
#+end_src

For =vcsh= (uses the git completer):

#+begin_src elvish
  use github.com/zzamboni/elvish-completions:vcsh
#+end_src

For =cd=:

#+begin_src elvish
  use github.com/zzamboni/elvish-completions:cd
#+end_src

*** Prompt theme

I use the [[https://github.com/zzamboni/theme.elv/blob/master/chain.org][chain]] prompt theme, ported from the fish theme at https://github.com/oh-my-fish/theme-chain.

#+begin_src elvish
  use github.com/zzamboni/elvish-themes/chain
  chain:bold-prompt = $true
#+end_src

Elvish has a [[https://elvish.io/ref/edit.html#prompts][comprehensive mechanism]] for displaying prompts with useful information while avoiding getting blocked by prompt functions which take too long to finish. For the most part the defaults work well. One change I like to make is to change the [[https://elvish.io/ref/edit.html#stale-prompt][stale prompt transformer]] function to make the prompt dim when stale:

#+begin_src elvish
  edit:prompt-stale-transform = { each [x]{ edit:styled $x[text] "gray" } }
#+end_src

Another possibility is to make the prompt stay the same when stale - useful to avoid distractions (disabled for now):

#+begin_src elvish :tangle no
  edit:prompt-stale-transform = $all~
#+end_src

I also like the continuous update of the prompt as I type (by default it only updates on Enter and on =$pwd= changes, but I like also git status changes to be updated automatically), so I increase its eagerness.

#+begin_src elvish
  edit:-prompt-eagerness = 10
#+end_src

*** Automatic proxy settings

When I am in the office, I need to use a proxy to access the Internet. For macOS applications, the proxy is set automatically using a company-provided PAC file. For the environment variables =http_proxy= and =https_proxy=, commonly used by command-line programs, the [[https://github.com/zzamboni/modules.elv/blob/master/proxy.org][proxy]] module allows me to define a test which determines when the proxy should be used, so that the change is done automatically.

First, we load the module and set the proxy host.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/proxy
  proxy:host = "http://proxy.corproot.net:8079"
#+end_src

Next, we set the test function to enable proxy auto-setting. In my case, the =/etc/resolv.conf= file contains the ~corproot.net~ domain (set through DHCP) when I'm in the corporate network, so I can check for that.

#+begin_src elvish
  proxy:test = {
    and ?(test -f /etc/resolv.conf) \
    ?(egrep -q '^(search|domain).*corproot.net' /etc/resolv.conf)
  }
#+end_src

*** Long-running-command notifications

The [[https://github.com/zzamboni/modules.elv/blob/master/long-running-notifications.org][long-running-notifications]] module allows for producing a notification when a command takes longer than a certain time to finish (by default the period is 10 seconds). The module automatically detects when [[https://github.com/julienXX/terminal-notifier][terminal-notifier]] is available on macOS and uses it to produce Mac-style notifications, otherwise it prints a notification on the terminal.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/long-running-notifications
#+end_src

*** Directory and command navigation and history

Elvish comes with built-in location and command history modes. I use the =narrow= module, which allow for more customization, including pre- and after- hooks for each of the modes. I use the default binding for history mode (~C-r~), but change the location mode binding to ~Alt-l~ to avoid conflicting with the binding of ~C-l~ to "clear screen" in =readline-binding=. I disable the lastcmd binding because it is taken over by the =bang-bang= module below.

#+begin_src elvish
  use narrow
  narrow:bind-trigger-keys &location=Alt-l &lastcmd=""
#+end_src

I have decades of muscle memory using ~!!~ and ~!$~ to insert the last command and its last argument, respectively. The [[https://github.com/zzamboni/elvish-modules/blob/master/bang-bang.org][bang-bang]] module allows me to keep using them.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/bang-bang
#+end_src

The [[https://github.com/zzamboni/modules.elv/blob/master/dir.org][dir]] module implements a directory history and some related functions. I alias the ~cd~ command to =dir:cd= so that any directory changes are kept in the history. I also alias =cdb= to =dir:cdb= function, which allows changing to the base directory of the argument.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/dir
  alias:new cd "use github.com/zzamboni/elvish-modules/dir; dir:cd"
  alias:new cdb "use github.com/zzamboni/elvish-modules/dir; dir:cdb"
#+end_src

=dir= also implements a narrow-based directory history chooser, which I bind to ~Alt-i~ (I have found I don't use this as much as I thought I would - the built-in location mode works nicely).

#+begin_src elvish
  edit:insert:binding[Alt-i] = $dir:history-chooser~
#+end_src

I bind =Alt-b/f= to =dir:left-word-or-prev-dir= and =dir:right-word-or-next-dir= respectively, which "do the right thing" depending on the current content of the command prompt: if it's empty, they move back/forward in the directory history, otherwise they move through the words of the current command. In my Terminal.app setup, =Alt-left/right= also produce =Alt-b/f=, so these bindings work for those keys as well.

#+begin_src elvish
  edit:insert:binding[Alt-b] = $dir:left-word-or-prev-dir~
  edit:insert:binding[Alt-f] = $dir:right-word-or-next-dir~
#+end_src

*** Dynamic terminal title

The [[https://github.com/zzamboni/elvish-modules/blob/master/terminal-title.org][terminal-title]] module handles setting the terminal title dynamically according to the current directory or the current command being executed.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/terminal-title
#+end_src

*** Loading private settings

The =private= module sets up some private settings such as authentication tokens. This is not on github :) The =$private-loaded= variable gets set to =$ok= if the module was loaded correctly.

#+begin_src elvish
  private-loaded = ?(use private)
#+end_src

*** O'Reilly Atlas

I sometimes use the [[https://atlas.oreilly.com/][O'Reilly Atlas]] publishing platform. The [[https://github.com/zzamboni/modules.elv/blob/master/atlas.org][atlas]] module contains some useful functions for triggering and accessing document builds.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/atlas
#+end_src

*** Smart matching for completion

The [[https://github.com/xiaq/edit.elv/blob/master/smart-matcher.elv][smart-matcher]] module tries prefix match, smart-case prefix match, substring match, smart-case substring match, subsequence match and smart-case subsequence match automatically.

#+begin_src elvish
  use github.com/xiaq/edit.elv/smart-matcher
  edit:completion:matcher[''] = $smart-matcher:match~
#+end_src

Other possible values for =edit:completion:matcher= are =[p]{ edit:match-prefix &smart-case $p }= for smart-case completion (if your pattern is entirely lower case it ignores case, otherwise it's case sensitive).  =&smart-case= can be replaced with =&ignore-case= to make it always case-insensitive.

*** Environment variables

Default options to =less=.

#+begin_src elvish
  E:LESS = "-i -R"
#+end_src

Use vim as the editor from the command line (although I am an [[https://github.com/zzamboni/dot-emacs/blob/master/init.org][Emacs]] fan, I still sometimes use vim for quick editing).

#+begin_src elvish
  E:EDITOR = "vim"
#+end_src

Locale setting.

#+begin_src elvish
  E:LC_ALL = "en_US.UTF-8"
#+end_src

*** Utility functions

The [[https://github.com/zzamboni/elvish-modules/blob/master/util.org][util]] module includes various utility functions.

#+begin_src elvish
  use github.com/zzamboni/elvish-modules/util
#+end_src

*** Exporting aliases

We populate =$-exports-= with the alias definitions so that they become available in the interactive namespace.

#+begin_src elvish
  -exports- = (alias:export)
#+end_src
* Emacs                                                               :emacs:
** TODO Using Proportional Fonts in Emacs with Org Mode :orgmode:beautifulemacs:
* Hammerspoon                                                   :hammerspoon:
* Elvish                                                             :elvish:
** DONE Bang-Bang (!!, !$) Shell Shortcuts in Elvish     :shell:unix:config:
CLOSED: [2017-12-04 Mon 22:15]
:PROPERTIES:
:export_file_name: 2017-12-04-bang-bang-shortcuts-in-elvish
:export_hugo_custom_front_matter: :featured_image /images/elvish-logo.svg :summary How to set up the bash !! and !$ shortcuts for accessing the previous command in Elvish.
:END:

(Updated on March 19th, 2018 to use the new [[https://elvish.io/ref/epm.html][Elvish Package Manager]])

The bash shortcuts (maybe older? I'm not sure in which shell these originated) for "last command" (=!!=) and "last argument of last command" (=!$=) are, for me at least, among the most strongly imprinted in my muscle memory, and I use them all the time. Although these shortcuts are not available in [[/post/elvish-an-awesome-unix-shell/][Elvish]] by default, they are easy to implement. I have written a module called [[https://github.com/zzamboni/elvish-modules/blob/master/bang-bang.org][bang-bang]] which you can readily use as follows:

- Use [[https://elvish.io/ref/epm.html][epm]] to install my elvish-modules package (you can also add this to your =rc.elv= file to have the package installed automatically if needed):

  #+begin_src elvish
    use epm
    epm:install github.com/zzamboni/elvish-modules
  #+end_src

- In your =rc.elv= (see [[/post/my-elvish-configuration-with-commentary/][mine]] as an example), add the following to load the =bang-bang= module and to set up the appropriate keybindings:

  #+BEGIN_SRC elvish
    use github.com/zzamboni/elvish-modules/bang-bang
  #+END_SRC

That's it! Start a new shell window, and test how command-history mode can be invoked by the =!= key. Assuming your last command was =ls -l ~/.elvish/rc.elv=, when you press =!= you will see the following:

#+BEGIN_EXAMPLE
  bang-lastcmd [A C] _
  ! ls -l .elvish/rc.elv
  0 ls
  1 -l
  2/$ .elvish/rc.elv
  Alt-! !
#+END_EXAMPLE

If you press =!= again, the whole last command will be inserted. If you press =$= (or =2=), only the last argument will be inserted. You can insert any other component of the previous command using its corresponding number. If you want to insert an exclamation sign, you can press =Alt-!=.

Note that by default, =Alt-!= will also be bound to trigger this mode, so you can fully replace the default [[https://elvish.io/learn/cookbook.html]["last command" mode]] in Elvish.

Have fun with Elvish!
