#+title: My Emacs Configuration, With Commentary
#+date: 2017-12-17T20:14:36+01:00
#+featured_image: /images/emacs-logo.svg
#+tags: emacs config
#+summary: I have enjoyed slowly converting my configuration files to literate programming style using org-mode in Emacs. It's now the turn of my Emacs configuration file.

I have enjoyed slowly converting my configuration files to [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate
programming]] style style using org-mode in Emacs. I previously posted
my [[../my-elvish-configuration-with-commentary/][Elvish configuration]], and now it's the turn of my Emacs
configuration file. The text below is included directly from my
[[https://github.com/zzamboni/dot_emacs/blob/master/init.org][init.org]] file. Please note that the text below is a snapshot as the
file stands today, but it is currently evolving See the [[https://github.com/zzamboni/dot_emacs/blob/master/init.org][file in GitHub]]
for my current, live configuration, and the generated file at
[[https://github.com/zzamboni/dot_emacs/blob/master/init.el]].

* Table of Contents

- [[#customized-variables][Customized variables]]
- [[#setting-up-the-package-system][Setting up the package system]]
- [[#settings][Settings]]
- [[#keybindings][Keybindings]]
- [[#system-specific-configuration][System-specific configuration]]
- [[#appearance-bufferfile-management-and-theming][Appearance, buffer/file management and theming]]
- [[#coding][Coding]]
- [[#other-tools][Other tools]]
- [[#general-text-editing][General text editing]]
- [[#org-mode][Org mode]]

* Customized variables

Emacs has its own [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Easy-Customization.html#Easy-Customization][Customization mechanism]] for easily customizing many
parameters. To make it easier to manage, I keep the customized
variables and faces in a separate file and load it from the main file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
#+END_SRC

You can see my current [[https://github.com/zzamboni/dot_emacs/blob/master/custom.el][custom.el]] in GitHub

* Setting up the package system

I use the [[https://www.masteringemacs.org/article/spotlight-use-package-a-declarative-configuration-tool][wonderful =use-package= package]]. As this is not bundled yet
with Emacs, the first thing we do is install it by hand. All other
packages are then declaratively installed and configured with
=use-package=. This makes it possible to fully bootstrap Emacs using
only this config file, everything else is downloaded, installed and
configured automatically.

First, we declare the package repositories to use.

#+BEGIN_SRC emacs-lisp
  (setq package-archives '(("gnu"       . "https://elpa.gnu.org/packages/")
                           ("marmalade" . "https://marmalade-repo.org/packages/")
                           ("melpa"     . "https://melpa.org/packages/")
                           ("org"       . "http://orgmode.org/elpa/")
                           ))
#+END_SRC

Then we initialize the package system, refresh the list of packages
and install =use-package= if needed.

#+BEGIN_SRC emacs-lisp
  (package-initialize)

  (when (not package-archive-contents)
    (package-refresh-contents))

  (when (not (package-installed-p 'use-package))
    (package-install 'use-package))
#+END_SRC

Finally, we set some configuration of =use-package= using itself - very
meta.

#+BEGIN_SRC emacs-lisp
  (use-package use-package
    :config
    (setq use-package-always-ensure t)) ; Always install missing packages
#+END_SRC

* Settings
** Proxy settings

These are two short functions I wrote to be able to set/unset proxy
settings within Emacs. I haven't bothered to improve or automate this,
as I pretty much only need it to be able to install packages sometimes
when I'm at work. For now I just call them manually with =M-x
set/unset-proxy= when I need to.

#+BEGIN_SRC emacs-lisp
  (defun set-proxy ()
    (interactive)
    (setq url-proxy-services '(("http" . "proxy.corproot.net:8079")
                               ("https" . "proxy.corproot.net:8079"))))
  (defun unset-proxy ()
    (interactive)
    (setq url-proxy-services nil))
#+END_SRC

** Miscellaneous settings

- This is probably one of my oldest settings - I remember adding it
  around 1993 when I started learning Emacs, and it has been in my
  config ever since. When =time-stamp= is run before every save, the
  string =Time-stamp: <>= in the first 8 lines of the file will be
  updated with the current timestamp.

  #+BEGIN_SRC emacs-lisp
    (add-hook 'before-save-hook 'time-stamp)
  #+END_SRC

- When at the beginning of the line, make =Ctrl-K= remove the whole
  line, instead of just emptying it.

  #+BEGIN_SRC emacs-lisp
    (setq kill-whole-line t)
  #+END_SRC

- Paste text where the cursor is, not where the mouse is.

  #+BEGIN_SRC emacs-lisp
    (setq mouse-yank-at-point t)
  #+END_SRC

- Make completion case-insensitive.

  #+BEGIN_SRC emacs-lisp
    (setq completion-ignore-case t)
    (setq read-file-name-completion-ignore-case t)
  #+END_SRC

- Show line numbers.

  #+BEGIN_SRC emacs-lisp
    (global-linum-mode)
  
    ;; Highlight trailing whitespace
    (setq show-trailing-whitespace t)
  #+END_SRC

- Highlight matching parenthesis

  #+BEGIN_SRC emacs-lisp
    (show-paren-mode 1)
  #+END_SRC

- Don't use hard tabs

  #+BEGIN_SRC emacs-lisp
    (setq-default indent-tabs-mode nil)
  #+END_SRC

- Emacs can automatically create backup files. This tells Emacs to [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html][put
  all backups in ~/.emacs.d/backups]].

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
#+END_SRC

- [[http://emacswiki.org/emacs/WinnerMode][WinnerMode]] makes it possible to cycle and undo window configuration
  changes (i.e. arrangement of panels, etc.)

  #+BEGIN_SRC emacs-lisp
    (when (fboundp 'winner-mode) (winner-mode 1))
  #+END_SRC

- Add "unfill" commands to parallel the "fill" ones.

  #+BEGIN_SRC emacs-lisp
    (use-package unfill)
  #+END_SRC

- Save the place of the cursor in each file, and restore it upon
  opening it again.

  #+BEGIN_SRC emacs-lisp
    (use-package saveplace
      :config
      (setq-default save-place t)
      (setq save-place-file (concat user-emacs-directory "places")))
  #+END_SRC

- Provide mode-specific "bookmarks" - press =M-i= and you will be
  presented with a list of elements to which you can navigate - they
  can be headers in org-mode, function names in emacs-lisp, etc.

  #+BEGIN_SRC emacs-lisp
    (use-package imenu-anywhere
      :config
      (global-set-key (kbd "M-i") 'ido-imenu-anywhere))
  #+END_SRC

- Smooth scrolling (line by line) instead of jumping by half-screens.

  #+BEGIN_SRC emacs-lisp
    (use-package smooth-scrolling
      :config
      (smooth-scrolling-mode 1))
  #+END_SRC

* Keybindings
** Miscellaneous keybindings

- =M-g= - interactively ask for a line number and jump to it (=goto-line)=.

  #+BEGIN_SRC emacs-lisp
    (global-set-key [(meta g)] 'goto-line)
  #+END_SRC

- =M-`= - if multiple frames are active, focus the next one (emulate the
  Mac "next app window" keybinding)

  #+BEGIN_SRC emacs-lisp
    (global-set-key [(meta \`)] 'other-frame)
  #+END_SRC

- Interactive search key bindings - make regex search the default. By
  default, =C-s= runs =isearch-forward=, so this swaps the bindings.

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-s") 'isearch-forward-regexp)
    (global-set-key (kbd "C-r") 'isearch-backward-regexp)
    (global-set-key (kbd "C-M-s") 'isearch-forward)
    (global-set-key (kbd "C-M-r") 'isearch-backward)
  #+END_SRC

- Key binding to use "[[http://www.emacswiki.org/emacs/HippieExpand][hippie expand]]" for text autocompletion

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "M-/") 'hippie-expand)
  #+END_SRC

** Emulating vi's =%= key

One of the few things I missed in Emacs from vi was the =%= key, which
jumps to the parenthesis, bracket or brace which matches the one below
the cursor. This function implements the functionality. Inspired by
[[http://www.emacswiki.org/emacs/NavigatingParentheses]], but modified to
use =smartparens= instead of the default commands, and to work on
brackets and braces.
  
#+BEGIN_SRC emacs-lisp
  (defun goto-match-paren (arg)
    "Go to the matching paren/bracket, otherwise (or if ARG is not nil) insert %.
    vi style of % jumping to matching brace."
    (interactive "p")
    (if (not (memq last-command '(set-mark
                                  cua-set-mark
                                  goto-match-paren
                                  down-list
                                  up-list
                                  end-of-defun
                                  beginning-of-defun
                                  backward-sexp
                                  forward-sexp
                                  backward-up-list
                                  forward-paragraph
                                  backward-paragraph
                                  end-of-buffer
                                  beginning-of-buffer
                                  backward-word
                                  forward-word
                                  mwheel-scroll
                                  backward-word
                                  forward-word
                                  mouse-start-secondary
                                  mouse-yank-secondary
                                  mouse-secondary-save-then-kill
                                  move-end-of-line
                                  move-beginning-of-line
                                  backward-char
                                  forward-char
                                  scroll-up
                                  scroll-down
                                  scroll-left
                                  scroll-right
                                  mouse-set-point
                                  next-buffer
                                  previous-buffer
                                  previous-line
                                  next-line
                                  )))
        (self-insert-command (or arg 1))
      (cond ((looking-at "\\s\(") (sp-forward-sexp) (backward-char 1))
            ((looking-at "\\s\)") (forward-char 1) (sp-backward-sexp))
            (t (self-insert-command (or arg 1))))))
#+END_SRC

We bind this function to the =%= key.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "%") 'goto-match-paren)
#+END_SRC

* System-specific configuration

Some settings maybe OS-specific, and this is where we set them. For
now I only use Emacs on my Mac, so only the Mac section is filled out,
but there are sections for Linux and Windows as well.

#+BEGIN_SRC emacs-lisp :noweb no-export
  (cond ((eq system-type 'darwin)
         <<Mac settings>>
         )
        ((eq system-type 'windows-nt)
         <<Windows settings>>
         )
        ((eq system-type 'gnu/linux)
         <<Linux settings>>
         ))
#+END_SRC

** Mac

First, we set the key modifiers correctly to my preferences: Make
Command act as Meta, Option as Alt, right-Option as Super

#+NAME: Mac settings
#+BEGIN_SRC emacs-lisp :tangle no
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier 'alt)
  (setq mac-right-option-modifier 'super)
#+END_SRC

We also make it possible to use the familiar ⌘-+ and ⌘-- to increase
and decrease the font size. ⌘-= is also bound to "increase" because
it's on the same key in an English keyboard.

#+NAME: Mac settings
#+BEGIN_SRC emacs-lisp :tangle no
  (global-set-key (kbd "M-+") 'text-scale-increase)
  (global-set-key (kbd "M-=") 'text-scale-increase)
  (global-set-key (kbd "M--") 'text-scale-decrease)
#+END_SRC

Somewhat surprisingly, there seems to be no "reset" function, so I
define my own and bind it to ⌘-0.

#+NAME: Mac settings
#+BEGIN_SRC emacs-lisp :tangle no
  (defun text-scale-reset ()
    (interactive)
    (text-scale-set 0))
  (global-set-key (kbd "M-0") 'text-scale-reset)
#+END_SRC

We also use the =exec-path-from-shell= to make sure the path settings
from the shell are loaded into Emacs (usually it starts up with the
default system-wide path).

#+NAME: Mac settings
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize))
#+END_SRC

** Linux

There are no Linux-specific settings for now.

#+NAME: Linux settings

** Windows

There are no Windows-specific settings for now.

#+NAME: Windows settings

* Appearance, buffer/file management and theming

Here we take care of all the visual, UX and desktop-management settings.

The =diminish= package makes it possible to remove clutter from the
modeline. Here we just load it, it gets enabled for individual
packages in their corresponding declarations.

#+BEGIN_SRC emacs-lisp
  (use-package diminish)
#+END_SRC

I have been playing with different themes, and I have settled for now
in =gruvbox=. Some of my other favorites are also here so I don't forget
about them.

#+BEGIN_SRC emacs-lisp
  ;;(use-package solarized-theme)
  ;;(use-package darktooth-theme)
  ;;(use-package kaolin-themes)
  (use-package gruvbox-theme)
  (load-theme 'gruvbox)
#+END_SRC

Enable desktop-save mode, which saves the current buffer configuration
on exit and reloads it on restart.

#+BEGIN_SRC emacs-lisp
  (use-package desktop
    :config
    (desktop-save-mode 1))
#+END_SRC

The =uniquify= package makes it much easier to identify different open
files with the same name by prepending/appending their directory or
some other information to them. I configure it to add the directory
name after the filename.

#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :ensure nil
    :config
    (setq uniquify-after-kill-buffer-p t)
    (setq uniquify-buffer-name-style 'post-forward)
    (setq uniquify-strip-common-suffix nil))
#+END_SRC

I like to highlight the current line and column. I'm still deciding
between two approaches:

- Using the built-in =global-hl-mode= to always highlight the current
  line, together with the =col-highlight= package, which highlights the
  column only after a defined interval has passed
- Using the =crosshairs= package, which combines both but always
  highlights both the column and the line. It also has a "highlight
  crosshairs when idle" mode, but I prefer to have the current line
  always highlighted, I'm only undecided about the always-on column
  highlighting.

Sometimes I find the always-highlighted column to be distracting, but
other times I find it useful. So I have both pieces of code here, I'm
still deciding.

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode 1)
  (use-package col-highlight
    :config
    (col-highlight-toggle-when-idle)
    (col-highlight-set-interval 2))
  ;; (use-package crosshairs
  ;;   :config
  ;;   (crosshairs-mode))
#+END_SRC

I use [[https://www.masteringemacs.org/article/introduction-to-ido-mode][IDO mode]] to get better matching capabilities everywhere in
Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package ido
    :config
    (ido-mode t)
    (ido-everywhere 1)
    (setq ido-use-virtual-buffers t)
    (setq ido-enable-flex-matching t)
    (setq ido-use-filename-at-point nil)
    (setq ido-auto-merge-work-directories-length -1))

  (use-package ido-completing-read+
    :config
    (ido-ubiquitous-mode 1))
#+END_SRC

I also use =recentf= to keep a list of recently open buffers, and define
a function to trigger recentf with IDO integration, using =C-x C-r= as
the keybinding.

#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :init
    (defun ido-recentf-open ()
      "Use `ido-completing-read' to \\[find-file] a recent file"
      (interactive)
      (if (find-file (ido-completing-read "Find recent file: " recentf-list))
          (message "Opening file...")
        (message "Aborting")))
    :config
    (recentf-mode 1)
    (setq recentf-max-menu-items 50)
    (global-set-key (kbd "C-x C-r") 'ido-recentf-open))
#+END_SRC

The [[http://martinowen.net/blog/2010/02/03/tips-for-emacs-ibuffer.html][=ibuffer=]] package allows all sort of useful operations on the list
of open buffers. I haven't customized it yet, but I have a keybinding
to open it.

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :config
    (global-set-key (kbd "C-x C-b") 'ibuffer))
#+END_SRC

The [[https://github.com/nonsequitur/smex][=smex=]] package is incredibly useful, adding IDO integration and some
other very nice features to =M-x=, which make it easier to discover and
use Emacs commands. Highly recommended.

#+BEGIN_SRC emacs-lisp
  (use-package smex
    :bind (("M-x" . smex))
    :config (smex-initialize))
#+END_SRC

[[https://www.emacswiki.org/emacs/MidnightMode][=midnight-mode=]] purges buffers which haven't been displayed in 3
days. We configure the period so that the cleanup happens every 2
hours (7200 seconds).

#+BEGIN_SRC emacs-lisp
  (use-package midnight
    :config
    (setq midnight-mode 't)
    (setq midnight-period 7200))
#+END_SRC

For distraction-free writing, I'm testing out =writeroom-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package writeroom-mode)
#+END_SRC

[[https://github.com/jaypei/emacs-neotree][NeoTree]] shows a navigation tree on a sidebar, and allows a number of
operations on the files and directories. I'm not much of a fan of this
type of interface in Emacs, but I have set it up to check it out.

#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :config
    (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
    (setq neo-smart-open t)
    (setq projectile-switch-project-action 'neotree-projectile-action)
    (defun neotree-project-dir ()
      "Open NeoTree using the git root."
      (interactive)
      (let ((project-dir (projectile-project-root))
            (file-name (buffer-file-name)))
        (neotree-toggle)
        (if project-dir
            (if (neo-global--window-exists-p)
                (progn
                  (neotree-dir project-dir)
                  (neotree-find file-name)))
          (message "Could not find git project root."))))
    (global-set-key [f8] 'neotree-project-dir))
#+END_SRC

=wc-mode= allows counting characters and words, both on demand and
continuously. It also allows setting up a word/character goal.

#+BEGIN_SRC emacs-lisp
  (use-package wc-mode)
#+END_SRC

The =all-the-icons= package provides a number of useful icons.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

* Coding

Coding is my main use for Emacs, so it's understandably the largest
section in my Emacs configuration.

** General settings and modules

When enabled, =subword= allows navigating "sub words" individually in
CamelCaseIdentifiers. For now I only enable it in =clojure-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package subword
    :config
    (add-hook 'clojure-mode-hook #'subword-mode))
#+END_SRC

With =aggressive-indent=, indentation is always kept up to date in the
whole buffer. Sometimes it gets in the way, but in general it's nice
and saves a lot of work, so I enable it for all programming modes.

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :diminish aggressive-indent-mode
    :config
    (add-hook 'prog-mode-hook #'aggressive-indent-mode))
#+END_SRC

With =company-mode=, we get automatic completion - when there are
completions available, a popup menu will appear when you stop typing
for a moment, and you can either continue typing or accept the
completion using the Enter key. I enable it globally.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish company-mode
    :config
    (add-hook 'after-init-hook #'global-company-mode))
#+END_SRC

=projectile-mode= allows us to perform project-relative operations such
as searches, navigation, etc.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :config
    (projectile-global-mode))
#+END_SRC

I find =iedit= absolutely indispensable when coding. In short: when
you hit =Ctrl-:=, all occurrences of the symbol under the cursor (or the
current selection) are highlighted, and any changes you make on one of
them will be automatically applied to all others. It's great for
renaming variables in code.

#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :config (set-face-background 'iedit-occurrence "Magenta"))
#+END_SRC

Turn on the online documentation mode for all programming modes (not
all of them support it) and for the Clojure REPL =cider= mode.

#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :config
    (add-hook 'prog-mode-hook #'turn-on-eldoc-mode)
    (add-hook 'cider-repl-mode-hook #'turn-on-eldoc-mode))
#+END_SRC

On-the-fly spell checking. I enable it for all text modes.

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :config
    (define-key flyspell-mouse-map [down-mouse-3] #'flyspell-correct-word)
    (define-key flyspell-mouse-map [mouse-3] #'undefined)
    (add-hook 'text-mode-hook   'flyspell-mode))
#+END_SRC

** Clojure and LISP coding

I dabble in Clojure and Emacs LISP, and Emacs has some fantastic
support for them. There's a number of packages and configuration
related to this, so I have a whole section for it.

The centerpiece is of course =clojure-mode=. In addition to files ending
in =.clj=, I bind it automatically to =.boot= files (both by extension and
by [[https://github.com/boot-clj/boot/wiki/For-Emacs-Users][shebang line]]) and to the [[http://riemann.io/][Riemann]] config files.

#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :mode "\\.clj.*$"
    :mode "riemann.config"
    :mode "\\.boot"
    :config
    (add-to-list 'magic-mode-alist '(".* boot" . clojure-mode)))
#+END_SRC

Enable some additional fontification for Clojure code.

#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode-extra-font-locking)
#+END_SRC

The =cider= package provides a fantastic REPL built into Emacs. We
configure a few aspects, including pretty printing, fontification,
history size and others.

#+BEGIN_SRC emacs-lisp
  (use-package cider
    :config
    ;; nice pretty printing
    (setq cider-repl-use-pretty-printing nil)

    ;; nicer font lock in REPL
    (setq cider-repl-use-clojure-font-lock t)

    ;; result prefix for the REPL
    (setq cider-repl-result-prefix "; => ")

    ;; never ending REPL history
    (setq cider-repl-wrap-history t)

    ;; looong history
    (setq cider-repl-history-size 5000)

    ;; persistent history
    (setq cider-repl-history-file "~/.emacs.d/cider-history")

    ;; error buffer not popping up
    (setq cider-show-error-buffer nil)

    ;; go right to the REPL buffer when it's finished connecting
    (setq cider-repl-pop-to-buffer-on-connect t))
#+END_SRC

We use =clj-refactor= for supporting advanced code refactoring in
Clojure.

#+BEGIN_SRC emacs-lisp
  (use-package clj-refactor
    :config
    (defun my-clojure-mode-hook ()
      (clj-refactor-mode 1)
      (yas-minor-mode 1) ; for adding require/use/import statements
      ;; This choice of keybinding leaves cider-macroexpand-1 unbound
      (cljr-add-keybindings-with-prefix "C-c C-m"))
    (add-hook 'clojure-mode-hook #'my-clojure-mode-hook))
#+END_SRC

Make the [[https://clojure.org/api/cheatsheet][Clojure cheatsheet]] available within Emacs when coding in
Clojure.

#+BEGIN_SRC emacs-lisp
  (use-package helm)
  (use-package clojure-cheatsheet
    :config
    (eval-after-load 'clojure-mode
      '(progn
         (define-key clojure-mode-map (kbd "C-c C-h") #'clojure-cheatsheet))))
#+END_SRC

When coding in LISP-like languages, =rainbow-delimiters= is a
must-have - it marks each concentric pair of parenthesis with
different colors, which makes it much easier to understand expressions
and spot mistakes.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

Another useful addition for LISP coding - =smartparens= enforces
parenthesis to match, and adds a number of useful operations for
manipulating parenthesized expressions.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :diminish smartparens-mode
    :config
    (require 'smartparens-config)
    (setq sp-base-key-bindings 'paredit)
    (add-hook 'clojure-mode-hook #'smartparens-strict-mode)
    (add-hook 'emacs-lisp-mode-hook #'smartparens-strict-mode)
    (add-hook 'lisp-mode-hook #'smartparens-strict-mode)
    (add-hook 'cider-repl-mode-hook #'smartparens-strict-mode))
#+END_SRC

Map =M-(= to enclose the next expression, as in =paredit=. Prefix argument
can be used to indicate how many expressions to enclose instead of
just 1. E.g. =C-u 3 M-(= will enclose the next 3 sexps.

#+BEGIN_SRC emacs-lisp
  (defun sp-enclose-next-sexp (num) (interactive "p") (insert-parentheses (or num 1)))
  (add-hook 'smartparens-mode-hook #'sp-use-paredit-bindings)
  (add-hook 'smartparens-mode-hook (lambda () (local-set-key (kbd "M-(") 'sp-enclose-next-sexp)))
#+END_SRC

Minor mode for highlighting the current sexp in LISP modes.

#+BEGIN_SRC emacs-lisp
  (use-package hl-sexp
    :config
    (add-hook 'clojure-mode-hook #'hl-sexp-mode)
    (add-hook 'lisp-mode-hook #'hl-sexp-mode)
    (add-hook 'emacs-lisp-mode-hook #'hl-sexp-mode))
#+END_SRC

** Other programming languages

Many other programming languages are well served by a single mode,
without so much setup as Clojure/LISP.

- [[http://cfengine.com/][CFEngine]] policy files.

  #+BEGIN_SRC emacs-lisp
    (use-package cfengine
      :commands cfengine3-mode
      :mode ("\\.cf\\'" . cfengine3-mode))
  #+END_SRC

- [[https://www.perl.org/][Perl]].

  #+BEGIN_SRC emacs-lisp
    ;; CPerl mode - doesn't auto-set the mode for some reason
    (use-package cperl-mode
      :mode "\\.p[lm]\\'"
      :interpreter "perl"
      :config
      (setq cperl-hairy t))
  #+END_SRC

- [[http://fishshell.com/][Fish shell]].

  #+BEGIN_SRC emacs-lisp
    ;; mode for editing fish shell scripts
    (use-package fish-mode
      :mode "\\.fish\\'"
      :interpreter "fish")
  #+END_SRC

- [[https://www.lua.org/][Lua]], which I use for [[http://zzamboni.org/tags/hammerspoon/][Hammerspoon]] configuration.

  #+BEGIN_SRC emacs-lisp
    (use-package lua-mode)
  #+END_SRC

- YAML, generally useful

  #+BEGIN_SRC emacs-lisp
    (use-package yaml-mode)
  #+END_SRC

- AppleScript

  #+BEGIN_SRC emacs-lisp
    (use-package applescript-mode)
  #+END_SRC

- Go

  #+BEGIN_SRC emacs-lisp
    (use-package go-mode)
  #+END_SRC

- Check MELPA package definitions

  #+BEGIN_SRC emacs-lisp
    (use-package package-lint)
  #+END_SRC

- [[http://elvish.io/][Elvish shell]]

  #+BEGIN_SRC emacs-lisp
    (use-package elvish-mode)
  #+END_SRC

- [[https://racket-lang.org/][Racket]]

  #+BEGIN_SRC emacs-lisp
    (use-package racket-mode)
  #+END_SRC

- [[https://nixos.org/nix/][Nix]] package files

  #+BEGIN_SRC emacs-lisp
    (use-package nix-mode)
  #+END_SRC

* Other tools

- git interace with some simple configuration I picked up somewhere

  #+BEGIN_SRC emacs-lisp
    (use-package magit
      :config
      (defadvice magit-status (around magit-fullscreen activate)
        "Make magit-status run alone in a frame."
        (window-configuration-to-register :magit-fullscreen)
        ad-do-it
        (delete-other-windows))

      (defun magit-quit-session ()
        "Restore the previous window configuration and kill the magit buffer."
        (interactive)
        (kill-buffer)
        (jump-to-register :magit-fullscreen))

      (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)
      (global-set-key (kbd "C-c C-g") 'magit-status))
  #+END_SRC

- Interface to use the [[https://geoff.greer.fm/ag/][=silver-searcher=]]

  #+BEGIN_SRC emacs-lisp
    (use-package ag)
  #+END_SRC

- Publishing with [[https://gohugo.io/][Hugo]]

  #+BEGIN_SRC emacs-lisp
    (use-package easy-hugo
      :config
      (setq easy-hugo-basedir "~/Personal/devel/zzamboni.org/zzamboni.org/")
      (setq easy-hugo-url "http://zzamboni.org/")
      (setq easy-hugo-previewtime "300")
      (define-key global-map (kbd "C-c C-e") 'easy-hugo))
  #+END_SRC

- Function to randomize the order of lines in a region, from
  [[https://www.emacswiki.org/emacs/RandomizeBuffer]].

#+BEGIN_SRC emacs-lisp
  (defun my-randomize-region (beg end)
    "Randomize lines in region from BEG to END."
    (interactive "*r")
    (let ((lines (split-string
                  (delete-and-extract-region beg end) "\n")))
      (when (string-equal "" (car (last lines 1)))
        (setq lines (butlast lines 1)))
      (apply 'insert
             (mapcar 'cdr
                     (sort (mapcar (lambda (x) (cons (random) (concat x "\n"))) lines)
                           (lambda (a b) (< (car a) (car b))))))))
#+END_SRC

* General text editing


In addition to coding, I configure some modes that can be used for
text editing.

- [[http://asciidoctor.org/docs/user-manual/][AsciiDoc]], which I use for [[http://cf-learn.info/][my book]] and some other text.

  #+BEGIN_SRC emacs-lisp
    (use-package adoc-mode
      :mode "\\.asciidoc\\'")
  #+END_SRC

- [[https://daringfireball.net/projects/markdown/syntax][Markdown]], generally useful.

  #+BEGIN_SRC emacs-lisp
    (use-package markdown-mode)
  #+END_SRC

- When [[https://www.emacswiki.org/emacs/TypographicalPunctuationMarks][=typopunct=]] is enabled (needs to be enable by hand in my config),
  automatically inserts “pretty” quotes of the appropriate type.

  #+BEGIN_SRC emacs-lisp
    (use-package typopunct
      :config
      (typopunct-change-language 'english t))
  #+END_SRC

* Org mode
:PROPERTIES:
:header-args: :noweb-ref org-mode-config
:END:

I have started using [[http://orgmode.org/][org-mode]] to writing, coding, presentations and
more, thanks to the hearty recommendations and information from [[http://www.cmdln.org/][Nick]]
and many others. I am duly impressed. I have been a fan of the idea of
[[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] for many years, and I have tried other tools
before (most notably [[https://www.cs.tufts.edu/~nr/noweb/][noweb]], which I used during grad school for many
of my homeworks and projects), but org-mode is the first tool I have
encountered which seems to make it practical. Here are some of the
resources I have found useful in learning it:

- Howard Abrams' [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][Introduction to Literate Programming]], which got me
  jumpstarted into writing code documented with org-mode.
- Nick Anderson's [[https://github.com/nickanderson/Level-up-your-notes-with-Org][Level up your notes with Org]], which contains many
  useful tips and configuration tricks.
- Sacha Chua's [[http://sachachua.com/blog/2014/01/tips-learning-org-mode-emacs/][Some tips for learning Org Mode for Emacs]], her [[http://pages.sachachua.com/.emacs.d/Sacha.html][Emacs
  configuration]] and many of her [[http://sachachua.com/blog/category/emacs/][other articles]].
- Rainer König's [[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][OrgMode Tutorial]] video series.

This is the newest and most-in-flux section of my Emacs config, since
I'm still learning org-mode myself.

First of all, we manually install the =org-plus-contrib= package, which
includes the latest version of =org= plus a lot of additional packages
from the =contrib/= directory, some of which I use.

#+BEGIN_SRC emacs-lisp :noweb-ref none
  (when (not (package-installed-p 'org-plus-contrib))
    (package-install 'org-plus-contrib))
#+END_SRC

Then I use =use-package= to load the =org= package, and put all its
configuration inside the =:config= section (=<<org-mode-config>>= is
replaced with all the org-related configuration blocks below).

#+BEGIN_SRC emacs-lisp :noweb no-export :noweb-ref none
  (use-package org
    :config
    <<org-mode-config>>
    )
#+END_SRC

** Keybindings

Set up =C-c l= to store a link to the current org object, in counterpart
to the default =C-c C-l= to insert a link.

#+BEGIN_SRC emacs-lisp :tangle no
  (define-key global-map "\C-cl" 'org-store-link)
#+END_SRC

Set up =C-c a= to call up agenda mode.

#+BEGIN_SRC emacs-lisp :tangle no
  (define-key global-map "\C-ca" 'org-agenda)
#+END_SRC

** General org-mode configuration

Automatically log done times in todo items (I haven't used this much
yet).

#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-log-done t)
#+END_SRC

Keep the indentation well structured by. OMG this is a must
have. Makes it feel less like editing a big text file and more like a
purpose built editor for org mode that forces the indentation. Thanks
[[https://github.com/nickanderson/Level-up-your-notes-with-Org/blob/master/Level-up-your-notes-with-Org.org#automatic-visual-indention][Nick]] for the tip!

#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-startup-indented t)
#+END_SRC

** Building presentations with org-mode

[[https://github.com/yjwen/org-reveal][=org-reveal=]] is an awesome package for building presentations with
org-mode.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ox-reveal
    :config
    (setq org-reveal-root "file:///Users/taazadi1/Dropbox/org/reveal.js")
    (use-package htmlize))
#+END_SRC

** Various exporters

One of the big strengths of org-mode is the ability to export a
document in many different formats. Here I load some of the exporters
I have found useful.

- Markdown

  #+BEGIN_SRC emacs-lisp :tangle no
    (require 'ox-md)
  #+END_SRC

- [[https://github.com/stig/ox-jira.el][Jira markup]]. I also load =org-jira=, which provides a full interface
  to Jira through org-mode.

  #+BEGIN_SRC emacs-lisp :tangle no
    (use-package ox-jira)
    (use-package org-jira
      :config
      ;; (setq jiralib-url "https://tracker.mender.io:443")
      (setq jiralib-url "https://jira.swisscom.com")
      (setq org-jira-working-dir "~/.org-jira"))
  #+END_SRC

- Confluence markup. This is included in org's contrib, so we just
  load it with =require= instead of =use-package=.

  #+BEGIN_SRC emacs-lisp :tangle no
    (require 'ox-confluence)
  #+END_SRC

- AsciiDoc

  #+BEGIN_SRC emacs-lisp :tangle no
    (use-package ox-asciidoc)
  #+END_SRC

** Keeping a Journal

I use [[http://750words.com/][750words]] for my personal Journal, and I usually write my entries
locally using Scrivener. I have been playing with =org-journal= for
this, but I am not fully convinced yet.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-journal
    :config
    (setq org-journal-dir "~/Documents/logbook"))
#+END_SRC

** Literate programming using org-babel

Org-mode is the first literate programming tool that seems practical
and useful, since it's easy to edit, execute and document code from
within the same tool (Emacs) using all of its existing capabilities
(i.e. each code block can be edited in its native Emacs mode, taking
full advantage of indentation, completion, etc.)

Plain literate programming is built-in, but the =ob-*= packages provide
the ability to execute code in different languages, beyond those
included with org-mode.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ob-cfengine3)
  (require 'ob-ruby)
  (require 'ob-latex)
  (require 'ob-plantuml)
  (setq org-plantuml-jar-path
        (expand-file-name "/usr/local/Cellar/plantuml/1.2017.18/libexec/plantuml.jar"))
  (require 'ob-python)
  (require 'ob-shell)
  (require 'ob-calc)
#+END_SRC

=inf-ruby= makes =ob-ruby= more powerful by providing a persistent Ruby
REPL.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package inf-ruby)
#+END_SRC

This is potentially dangerous: it suppresses the query before
executing code from within org-mode. I use it because I am very
careful and only press =C-c C-c= on blocks I absolutely understand.

#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-confirm-babel-evaluate nil)
#+END_SRC

This makes it so that code within src blocks is fontified according to
their corresponding Emacs mode, making the file much more readable.

#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-src-fontify-natively t)
#+END_SRC

In principle this makes it so that indentation in src blocks works as
in their native mode, but in my experience it does not always work
reliably. For full proper indentation, always edit the code in a
native buffer by pressing =C-c '=.

#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-src-tab-acts-natively t)
#+END_SRC

Automatically show inline images, useful when executing code that
produces them, such as PlantUML or Graphviz.

#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
#+END_SRC

This little snippet has revolutionized my literate programming
workflow. It automatically runs =org-babel-tangle= upon saving any
org-mode buffer, which means the resulting files will be automatically
kept up to date.

#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'org-mode-hook
            (lambda () (add-hook 'after-save-hook 'org-babel-tangle
                                 'run-at-end 'only-in-org-mode)))
#+END_SRC

** Beautifying org-mode

These settings make org-mode much more readable by using different
fonts for headings, hiding some of the markup, etc. This was taken
as-is from
[[http://www.howardism.org/Technical/Emacs/orgmode-wordprocessor.html]].

#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-hide-emphasis-markers t)
  (font-lock-add-keywords 'org-mode
                          '(("^ +\\([-*]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
  (use-package org-bullets
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
  (let* ((variable-tuple (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
                               ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
                               ((x-list-fonts "Verdana")         '(:font "Verdana"))
                               ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                               (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
         (base-font-color     (face-foreground 'default nil 'default))
         (headline           `(:inherit default :weight bold :foreground ,base-font-color)))

    (custom-theme-set-faces 'user
                            `(org-level-8 ((t (,@headline ,@variable-tuple))))
                            `(org-level-7 ((t (,@headline ,@variable-tuple))))
                            `(org-level-6 ((t (,@headline ,@variable-tuple))))
                            `(org-level-5 ((t (,@headline ,@variable-tuple))))
                            `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
                            `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
                            `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
                            `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
                            `(org-document-title ((t (,@headline ,@variable-tuple :height 1.5 :underline nil))))))
#+END_SRC

** Auto-generated table of contents

The =toc-org= package allows us to insert a table of contents in
headings marked with =:TOC:=. This is useful for org files that are to
be viewed directly on GitHub, which renders org files correctly, but
does not generate a table of contents at the top.

Note that this breaks HTML export by default, as the links generated
by =toc-org= cannot be parsed properly by the html exporter. The
[[https://github.com/snosov1/toc-org/issues/35#issuecomment-275096511][workaround]] is to use =:TOC:noexport:= as the marker, which removed the
generated TOC from the export, but still allows =ox-html= to insert its
own TOC at the top.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package toc-org
    :config
    (add-hook 'org-mode-hook 'toc-org-enable))
#+END_SRC

** Grabbing links from different Mac applications

=org-mac-link= (included in contrib) implements the ability to grab
links from different Mac apps and insert them in the file. Bind =C-c g=
to call =org-mac-grab-link= to choose an application and insert a link.

#+BEGIN_SRC emacs-lisp :tangle no
  (require 'org-mac-link)
  (add-hook 'org-mode-hook (lambda ()
                             (define-key org-mode-map (kbd "C-c g") 'org-mac-grab-link)))
#+END_SRC

